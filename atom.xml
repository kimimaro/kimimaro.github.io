<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[402]]></title>
  <link href="http://blog.oneboxapp.com/atom.xml" rel="self"/>
  <link href="http://blog.oneboxapp.com/"/>
  <updated>2015-09-18T13:05:41+08:00</updated>
  <id>http://blog.oneboxapp.com/</id>
  <author>
    <name><![CDATA[Kimimaro]]></name>
    <email><![CDATA[kimirius@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[拖延症的治疗方法【from Quora】]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150917/tuo-yan-zheng-de-zhi-liao-fang-fa-%5B(from-quora)%5D/"/>
    <updated>2015-09-17T17:34:19+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150917/tuo-yan-zheng-de-zhi-liao-fang-fa-[(from-quora)]</id>
    <content type="html"><![CDATA[<p> Quora翻译第二弹，依然是来自<a href="https://www.quora.com/Oliver-Emberton">Oliver Emberton</a>的回答，这次的问题是：<a href="https://www.quora.com/How-can-I-stop-procrastinating-7">How can I stop procrastinating? - Quora</a>——咋能治治俺的拖延症？</p>

<blockquote>
  <p>刚开始OE给了一大段的很有意思、极其生动的铺垫。</p>
</blockquote>

<p><strong>我将要回答你的问题，但首先允许我花费两分钟通过时间通过一条卡通蛇来阐述一下人类文明。</strong></p>

<p> 人们总是认为自己非常聪明。当然那些伟大的、极聪明的大脑让我们能切开原子、登上月球，然而，这个同样也是愚蠢的大脑让我们直到天黑也没法开始一项工作。</p>

<p> 我们从原始人类进化而来，但是我们从未完全从他们的遗赠中蜕变出来。你认识大脑中那个聪明的、理性的，用于保持人类头脑清醒的部分吧？让我们把他叫做<strong>Albert</strong>，他住在我们的大脑中，而他的邻居，则是一个容易冲动的、幼小的爬行动物，一个叫做<strong>Rex</strong>的家伙。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-231e3cf0e3602dbec6620883d2679020.png?imageView/2/w/500/q/90" alt="" /></p>

<p> 你知道如果遇见一个前凸后翘的美女你没办法控制自己不去注意一下吧？那就是Rex，无论你多么努力也<em>无法将他彻底关掉</em>。他是你的本能、你的冲动、你的爱和你的恐惧。</p>

<p> 人们总是认为Albert才是“真正的自己”——我们大脑中清醒的部分。他是那个用于讲话、理性的部分。当我们决定去健身房或者开始写毕业论文的时候，是Albert做的决定。当时Albert是年老体衰、容易疲惫的，<em>通常都是处于关闭状态</em>。</p>

<p> 于是你的大脑被困在了一个总是昏昏欲睡的老教授和一个仿佛精力无限的、容易冲的小爬行动物之间相互斗争的围城里。同时你偏偏将掌舵的大权交给了那个小动物。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-6ab03ac71e155b68284e907bc3903027.png?imageView/2/w/500/q/90" alt="" /></p>

<p> Rex确实会听Albert的话。就像孩子一样，他大多数时间会听从Albert的指挥，只要他没有太强烈的反对。可是，如果Rex极其强烈的渴望冲到沙发上看<a href="http://www.bilibili.com/video/av1566692/">幸存者</a>、吃<a href="https://www.facebook.com/Cheetos">奇多</a>，那么十有八九你就会找着去做了。</p>

<p> 在我们周围人类取得的那些难以执行的成就绝大多数归功于我们对大脑中那个Rex的培养教育，去掌控他、抚慰他、推到他。</p>

<p> 我们将许许多多这样的系统称之为“人类文明”。广泛的说食物和房屋占据了“文明”的很大一部分。还包括法律与正义、义务教育、娱乐、一夫一妻制等等。所有这些都是用来让Rex保持安静，好让Albert有时间和精力去做一些有意义的事情——像发现青霉素或者发明<a href="https://www.facebook.com/Cheetos">奇多</a>。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-d65915fb7e9b65537d5244ba8a41b2b5.png?imageView/2/w/500/q/90" alt="" /></p>

<p>现在，让我们回头来看看你的拖延症问题。</p>

<p> 你通过清醒的大脑做了一个明智的决定，却奇怪自己为什么没有坚持下来。真实的原因是你的日常决策者——Rex——还没有那么成熟。</p>

<p> 设想一下你不得不不断的说服一个小孩子按照你说的做事情。对于一些简单的事情，假设你的权威性足够的情况下。比如你告诉他：“到吃晚饭的时间了”。可是加入他不想做这件事情，他就不会听你的，这时你不得不耐下性子好言相劝：</p>

<blockquote>
  <p><strong>以下是OE交给你的治疗拖延症的方法</strong></p>
</blockquote>

<ul>
  <li><strong>忘掉逻辑</strong>。一旦你决定做一件事情，逻辑合理性无法帮到你。你内心的小爬行动物可以被取悦、被恐吓、被激励，但永远不会听你讲道理。</li>
  <li><strong>保持自己舒适</strong>。当你饥饿、疲惫或者不高兴的时候，内心的小Rex就会造反了。如果不能照顾好你自己，Rex就会哭闹并拒绝你要求的一切事情。<strong>这正是她想要的</strong>，吃饭、睡觉、打豆豆。</li>
  <li><strong>赏罚分明</strong>。建立日常的、强制性的奖惩机制。如果你想要一个小孩儿吃蔬菜，就不要提前给他吃甜点。在成功的时候奖励你自己，在失败的时候给自己可以量性的惩罚。经典的案例就是将你的目标公布出去或者找一个团队一起努力——社交压力会影响Rex。</li>
  <li><strong>煽动自己</strong>。你的爬行动物大脑只对情感有反应。因此，保持自己紧张的、或者是有所畏惧的状态。有动机的谈话、电影或者文章都是很有效的途径，在一段时间内。我自己利用的是振奋人心的音乐（我最喜欢的歌单之一是<a href="http://open.spotify.com/user/oliveremberton/playlist/4ifk7EG0SLkV0En6s0ds7g">Music to conquer worlds by</a>）。想象一下完成这件事之后内心的喜悦，或者失败带来的恐惧。利用想象力使其生动起来以至于可以触动到你。我们用相同的技巧来教导小孩子：“说谎话鼻子会变长”或者“西瓜子吃进去肚子里会长西瓜”。</li>
  <li><strong>强迫开始</strong>。你要做的最重要的一件事就是开始。Rex大部分的本能是避免变化，一旦你确定开始做某件事情的时候Rex的本能就开始发生变化。只要有足够长的时间，你甚至可以说服Rex喜欢上他原来讨厌的事情。我们强迫孩子去上学、去上钢琴课并不是完全没有理由的。</li>
  <li><strong>清空你的周围</strong>。Rex是短视的，脑瓜儿也不是很灵活。如果他看到微信图标，他就会想去点它。这就好像在小孩子上床睡觉前给他看一下刚刚开始的精彩动画片。将你周遭的环境设计成远离干扰的：登出即时聊天工具、关掉通知、关掉邮件。将工作和找乐子的地方分离开，最好远离电脑（至少远离社交网络）。</li>
</ul>

<p> 一旦你知道自己在寻找什么，就能够开始认识这个模式并且控制他们。</p>

<p> 每个人的大脑中都有一个容易冲动的幼小的爬行动物，而且很不幸的是大脑的掌舵大权偏偏在他的手中。如果你能够成为一名好的家长让他尽可能的按你说的做，很好的服务与你。时刻记住谁在负责控制你的思想。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoodBooks]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150916/goodbooks/"/>
    <updated>2015-09-16T20:37:37+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150916/goodbooks</id>
    <content type="html"><![CDATA[<h3 id="dev">Dev</h3>
<ul>
  <li><a href="https://www.gitbook.com/explore">Explore - GitBook</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS富文本组件的实现-CoreText vs TextKit]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150916/iosfu-wen-ben-zu-jian-de-shi-xian-coretext-vs-textkit/"/>
    <updated>2015-09-16T18:00:44+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150916/iosfu-wen-ben-zu-jian-de-shi-xian-coretext-vs-textkit</id>
    <content type="html"><![CDATA[<h1 id="ios">iOS富文本实现</h1>

<p> 在iOS7之前，系统展现文字的方式只有UILabel、UITextView这样的简单控件，如果要实现复杂的富文本展现，则需要开发者自己调用CoreText去实现，开发的复杂程度非常大。</p>

<p> iOS7之前最优秀的实现应该是开源项目：<a href="https://github.com/Cocoanetics/DTCoreText">Cocoanetics/DTCoreText</a>，通过解析HTML和CSS文件最终用CoreText绘制。（UIWebView应该不会有人用吧 = .=）基于JavascriptCore应该也可以解析渲染出元素丰富的界面，但是没有HTML和CSS来的直观。</p>

<h1 id="dtcoretext">DTCoreText</h1>
<blockquote>
  <p>有关这个项目bang神的blog写的很赞。</p>
</blockquote>

<ul>
  <li><a href="http://blog.cnbang.net/tech/2630/">iOS富文本组件的实现—DTCoreText源码解析 数据篇 « bang’s blog</a></li>
  <li><a href="http://blog.cnbang.net/tech/2729/">iOS富文本组件的实现—DTCoreText源码解析 渲染篇 « bang’s blog</a></li>
  <li>基于DTCoreText实现的富文本项目Demo演示</li>
</ul>

<h1 id="textkit">TextKit</h1>
<blockquote>
  <p>iOS7上终于等来了TextKit，有关的介绍和吐槽都在这里：</p>
</blockquote>

<ul>
  <li><a href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/">Getting to Know TextKit · objc.io</a></li>
</ul>

<h1 id="section">总结</h1>
<p> 综合来讲TextKit已经具备了富文本展现的一切必备功能：整段缩进、截断（加省略号）、连字符、对齐、文本样式、文本效果、图片视频附件，但就多媒体附件这一块似乎支持的还没有DTCoreText那么灵活，只能插入固定的类型而不是插入一个View。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Crash Log分析实战]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150914/crash-logfen-xi-shi-zhan/"/>
    <updated>2015-09-14T15:56:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150914/crash-logfen-xi-shi-zhan</id>
    <content type="html"><![CDATA[<blockquote>
  <p>事情的缘起是收到了一个用户的线上Crash反馈，QA无法复现，但是作为体量大开发质量又追求极致的应用通常还得解决这样的问题。</p>

  <p>通过各种努力终于拿到了用户的Crash Log，结果符号化后的崩溃线程堆栈里面竟然一条有用的信息都找不到，WTF！
<!--more-->
崩溃日志如下：（出于公司隐私考虑去掉了部分符号）</p>
</blockquote>

<pre><code>{"name":"XXXApp","bug_type":"109","os_version":"iPhone OS 7.1.1 (11D201)","bundleID":"com.xxx","version":"6.7.1.0 (6.7.1)","app_name":"XXXApp"}
Incident Identifier: EC2DC883-C0DB-4FD6-81FB-237626598366
CrashReporter Key:   d5c091bc35732df06fcaf41e5786833159b04ea5
Hardware Model:      iPhone5,2
Process:             XXXApp [1912]
Path:                /var/mobile/Applications/4E3E131C-5847-4B61-A0E0-D350830C1693/BaiduBoxApp.app/XXXApp
Identifier:          com.xxx
Version:             6.7.1.0 (6.7.1)
Code Type:           ARM (Native)
Parent Process:      launchd [1]

Date/Time:           2015-08-28 00:37:32.658 +0800
OS Version:          iOS 7.1.1 (11D201)
Report Version:      104

Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  0

Thread 0 Crashed:
0   libsystem_kernel.dylib        	0x39c636d8 __kill + 8
1   Foundation                    	0x2f901c1e __NSThreadPerformPerform + 382
2   CoreFoundation                	0x2eee3fec __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 12
3   CoreFoundation                	0x2eee34b2 __CFRunLoopDoSources0 + 202
4   CoreFoundation                	0x2eee1ca2 __CFRunLoopRun + 626
5   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
6   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
7   GraphicsServices              	0x33db96ce GSEventRunModal + 134
8   UIKit                         	0x317ab88c UIApplicationMain + 1132
9   BaiduBoxApp                   	0x0006d13e main (main.m:17)
10  libdyld.dylib                 	0x39badab4 start + 0

Thread 1:
0   libsystem_kernel.dylib        	0x39c51804 kevent64 + 24
1   libdispatch.dylib             	0x39ba0050 _dispatch_mgr_invoke + 228
2   libdispatch.dylib             	0x39b9a2de _dispatch_mgr_thread + 34

Thread 2 name:  com.apple.NSURLConnectionLoader
Thread 2:
0   libsystem_kernel.dylib        	0x39c51a50 mach_msg_trap + 20
1   libsystem_kernel.dylib        	0x39c51848 mach_msg + 36
2   CoreFoundation                	0x2eee3624 __CFRunLoopServiceMachPort + 152
3   CoreFoundation                	0x2eee1d44 __CFRunLoopRun + 788
4   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
5   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
6   Foundation                    	0x2f88c23c +[NSURLConnection(Loader) _resourceLoadLoop:] + 316
7   Foundation                    	0x2f901a0a __NSThread__main__ + 1058
8   libsystem_pthread.dylib       	0x39ccb956 _pthread_body + 138
9   libsystem_pthread.dylib       	0x39ccb8c6 _pthread_start + 98
10  libsystem_pthread.dylib       	0x39cc9ae4 thread_start + 4

Thread 3 name:  com.apple.CFSocket.private
Thread 3:
0   libsystem_kernel.dylib        	0x39c64434 __select + 20
1   CoreFoundation                	0x2eee751e __CFSocketManager + 482
2   libsystem_pthread.dylib       	0x39ccb956 _pthread_body + 138
3   libsystem_pthread.dylib       	0x39ccb8c6 _pthread_start + 98
4   libsystem_pthread.dylib       	0x39cc9ae4 thread_start + 4

...
</code></pre>

<blockquote>
  <p>于是只好把各种exception type和C signal分析了一遍，希望能找到一些蛛丝马迹。</p>
</blockquote>

<h1 id="crash-log">Crash Log分析实例</h1>

<h3 id="exccrash-sigsegv">1. 首先还是来看看 EXC_CRASH (SIGSEGV)</h3>

<p><strong>Crash Log分析的标准姿势</strong>一般是这样的：</p>

<ol>
  <li>在用户的Crash日志文件查看应用版本，找到发布版本时的Archive包；</li>
  <li>其实我们只需要Archive包中的.app文件或者dSYM文件，二者中的一个即可；</li>
  <li>符号化日志中的内存地址，符号化出来的日志文件中的地址会被转换成对应的代码及行数，<strong>符号化的方法</strong>有如下几种：
    <ul>
      <li>mdimport dSYM文件，步骤如下：
        <ol>
          <li>找到对应版本的dSYM文件</li>
          <li>
            <p>导入到Xcode中，注意要用绝对路径，运行代码：</p>

            <pre><code> mdimport /Users/kimimaro/Desktop/log/XXXAPP.app.dSYM/
</code></pre>
          </li>
          <li>在Xcode中运行Re-symbolicate后查看结果</li>
          <li>顺便吐槽一下新版Xcode越来越不好用，Xcode6还没找到从外部导入crash文件之后执行Re-symbolicate的方法。真机里面的crash log用Xcode打开后，Window -&gt; Devices -&gt; 找到对应设备 -&gt; View Device Logs -&gt; 右键对应Log条目 -&gt; Re-symbolicate。</li>
        </ol>
      </li>
      <li>利用symbolicatecrash工具（<strong>因为方便所以更为常用</strong>）
        <ol>
          <li>
            <p>找到Symbolicatecrash文件（Symbolicatecrash文件独立于Xcode，可以拷出来使用）;</p>

            <pre><code> /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/
</code></pre>

            <p>或运行如下命令找到</p>

            <pre><code> find /Applications/Xcode.app -name symbolicatecrash -type f
</code></pre>
          </li>
          <li>
            <p>用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起，将Crash文件也拷到当前文件夹里面;</p>

            <pre><code> cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash /Users/kimimaro/Desktop/crash
</code></pre>
          </li>
          <li>
            <p>终端中输入命令，命令格式：Symbolicatecrash + 崩溃日志 + APP对应的.dSYM文件 + &gt; + 输出到的文件;</p>

            <pre><code> Symbolicatecrash .crash .dSYM &gt; a.log
</code></pre>
          </li>
          <li>将终端完成以后，在crash文件夹里面会多出一个文件a.log，这个就是最终的文件，可以查看bug所在；</li>
          <li>
            <p>如果提示”DEVELOPER_DIR” is not defined;</p>

            <pre><code> 在终端中输入： export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer
</code></pre>
          </li>
        </ol>
      </li>
      <li>直接执行atos命令（symbolicatecrash里面也是用了这个工具）
        <ol>
          <li>
            <p>计算symbol address，iOS某个版本之后新的crash日志的地址计算方式发生了改变，所以需要我们先手动计算一下（当然也可以写脚本算哈~）</p>

            <pre><code> slide: 0x00001000 
 stack address: 0x0006da48 
 load address: 0x5c000
			
 symbol address = slide + stack address - load address = 00012a48
</code></pre>
          </li>
          <li>
            <p>找到symbol address对应的代码行</p>

            <pre><code> atos -arch [arch] -o [dwarf]   [address]
 eg. atos -arch armv7 -o Joke.app/Joke 00012a48
			
 atos命令的一些参数如下：atos -o EXECUTABLE -arch ARCHITECTURE -l LOAD_ADDRESS ADDRESS
</code></pre>
          </li>
          <li>
            <p>再啰嗦一句，如果依赖atos写脚本的话就用：</p>

            <pre><code> xcrun atos -arch armv7s -o [dwarf]   [address]
</code></pre>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p>在符号化后的日志中找到：</p>

    <pre><code> Triggered by Thread:  0
</code></pre>

    <p>根据所指示的找到崩溃的线程，然后happy happy的在里面找到崩溃的函数；</p>
  </li>
</ol>

<p> 但是往往当我们找到崩溃线程的时候发现不能happy的解Bug了，因为对应的线程里面竟然全都是系统调用，一个应用内调用的方法都没有，ORZ。</p>

<blockquote>
  <p>接下来的分析可能就根据对应问题不同分析的手段也不同，但是总得来说还是有一些规律可寻的。</p>
</blockquote>

<h3 id="exception-type--c-signle">2. Exception Type &amp; C signle</h3>

<p> 上面Log里面的可以找到这样两行：</p>

<pre><code>Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
</code></pre>

<p> 第一行是这个崩溃日志的类型，由”Mach Exception”（以”EXC_“开头的）和”UNIX Signal”（如 SIGSEGV, SIGBUS 等）两部分组成。对于某些exceptions，也会附加一个处理器特定的Exception Code / Exception Subtype，包含和exception有关的信息。比如：“EXC_BAD_ACCESS”下面经常会看到“KERN_INVALID_ADDRESS at 0x80000010”这样的exception code；“EXC_RESOURCE”下面会看到“WAKEUPS”这样的exception subtype。</p>

<p> <strong>Mach Exception常见的有如下几种：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Exception类型</th>
      <th style="text-align: left">描述</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">EXC_BAD_ACCESS</td>
      <td style="text-align: left">Bad Memory Access</td>
      <td>错误内存地址，访问的地址不存在或者当前进程没有权限都会报这个错。通常后面跟随的UNIX Signal是<strong>SIGBUS</strong>或者<strong>SIGSEGV</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_CRASH</td>
      <td style="text-align: left">Abnormal Exit</td>
      <td>通常跟随的UNIX Signal是<strong>SIGABRT</strong>，当前进程被系统检测到有异常行为而杀死</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_BREAKPOINT</td>
      <td style="text-align: left">Trace / breakpoint Trap</td>
      <td>通常跟随的UNIX Signal是<strong>SIGTRAP</strong>，一般来说代码中主动抛出异常时发生。</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_GUARD</td>
      <td style="text-align: left">Violated Guarded Resource Protection</td>
      <td>侵犯了被监视资源的安全性，比如：确定的文件描述</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_BAD_INSTRUCTION</td>
      <td style="text-align: left">Illegal Instruction</td>
      <td>非法或未定义的指令或操作数</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_RESOURCE</td>
      <td style="text-align: left">Resource Limit</td>
      <td>达到资源极限时的App Crash</td>
    </tr>
    <tr>
      <td style="text-align: left">00000020</td>
      <td style="text-align: left">Hexadecimal Exception Type</td>
      <td>非“OS内核”异常</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>完整的Mach Exception列表可以在<a href="http://fxr.watson.org/fxr/source/osfmk/mach/exception_types.h?v=xnu-2050.18.24">这里</a>的源代码文件（sys/osfmk/mach/exception_types.h）中找到。</p>
</blockquote>

<p> <strong>UNIX Signal常见的有如下几种：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">UNIX Signal</th>
      <th style="text-align: left">解释说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">SIGSEGV</td>
      <td style="text-align: left">访问了无效的内存地址，这个地址存在，但是当前进程没有权限访问它。<strong>属于硬件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGABRT</td>
      <td style="text-align: left">程序Crash，这个符号是由C函数abort()触发的。通常代表系统发现当前程序执行出错。<strong>属于软件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGBUS</td>
      <td style="text-align: left">访问了无效的内存地址，与SIGSEGV的区别是：SIGBUS表示内存地址不存在。<strong>属于硬件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGTRAP</td>
      <td style="text-align: left">Debugger相关</td>
    </tr>
    <tr>
      <td style="text-align: left">SIGILL</td>
      <td style="text-align: left">尝试执行一个非法的、未知的、没有权限的指令</td>
    </tr>
  </tbody>
</table>

<p> 上面两个表格只能帮助理解区分，实际定位问题时需要更深入的理解。举个例子说，比如上述Crash Log实例中：</p>

<ol>
  <li>
    <p>EXC_CRASH</p>

    <ul>
      <li>EXC_CRASH is a mach exception that just means the application terminated abnormally. The parenthetical is the signal that caused the exception, in your case it’s SIGABRT which almost always means that you have an un-handled exception somewhere or you have some code that is calling abort() for some reason (again, generally the un-handled exception handler calls this in the end).</li>
      <li>可能导致问题的原因：
        <ul>
          <li>unrecognized selector</li>
        </ul>
      </li>
      <li>调试方法：
        <ul>
          <li>All Exception Point</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>EXC_BAD_ACCESS</p>

    <ul>
      <li>可能导致该问题的原因：
        <ul>
          <li>memory errors</li>
        </ul>
      </li>
      <li>调试方法：
        <ul>
          <li>NSZombie</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>SIGSEGV</p>

    <ul>
      <li>在POSIX兼容的平台上，SIGSEGV是当一个进程执行了一个无效的内存引用，或发生段错误时发送给它的信号。SIGSEGV的符号常量在头文件signal.h中定义。因为在不同平台上，信号数字可能变化，因此符号信号名被使用。通常，它是信号#11。</li>
      <li>SIG是信号名的通用前缀。SEGV是segmentation violation（段违例）的缩写。</li>
      <li>它會出現在當程式企圖存取CPU無法定址的記憶體區段時。</li>
      <li>可能导致该问题的原因：
        <ul>
          <li>引用released对象</li>
          <li>引用从未init的对象</li>
          <li>数组越界</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>SIGABRT</p>

    <ul>
      <li>软件层（系统层）的错误</li>
      <li>可能导致该问题的原因：
        <ul>
          <li>try to free the same memory twice</li>
          <li>raise Exception</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>结合Exception Type和UNIX Signal可以看出：</p>
    <ul>
      <li>这个Log中显示的崩溃是一种比较异常的情况：（Mach Exception Type和C signal常识上不匹配）；</li>
      <li>程序崩溃的原因比较大的可能仍是<strong>访问了无效的内存地址</strong>。</li>
    </ul>
  </li>
</ol>

<h3 id="section">3. 崩溃线程中的系统调用</h3>
<blockquote>
  <p>接着Exception Type部分往下看，程序崩溃在了Thread 0，那么我们就来看一下Thread 0的内存堆栈。</p>
</blockquote>

<p> 如上面所说崩溃线程中除了main.m方法属于App源码外，其他皆为系统调用。</p>

<pre><code>2   CoreFoundation                	0x2eee3fec __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 12
3   CoreFoundation                	0x2eee34b2 __CFRunLoopDoSources0 + 202
4   CoreFoundation                	0x2eee1ca2 __CFRunLoopRun + 626
5   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
6   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
7   GraphicsServices              	0x33db96ce GSEventRunModal + 134
8   UIKit                         	0x317ab88c UIApplicationMain + 1132
</code></pre>

<p>上面这个部分的堆栈是很平常的系统调用堆栈，在main方法执行后通常都会看到它们。重点是再上面这一句：</p>

<pre><code>1   Foundation                    	0x2f901c1e __NSThreadPerformPerform + 382
</code></pre>

<p>这个方法告诉我们很大可能是<strong>在我们调用performSelector:系列方法时程序发生崩溃</strong>的。</p>

<pre><code>_NSThreadPerformPerform is used by the performSelector... family of methods. So look at your use of those methods. In particular, figure out if it's possible that you're asking an object to perform a selector that it doesn't support. That would throw an exception.
</code></pre>

<h3 id="section-1">4. 判断当前程序正在运行的时机</h3>
<blockquote>
  <p>其他线程虽然不是导致崩溃的线程，但是根据其他线程中的可识别代码，可以大致判断出当前程序所处于的时期（程序启动、程序运行期、前后台切换等等），缩小问题定位的范围。</p>
</blockquote>

<p> 在上述Crash Log例子中通过其他线程正在执行的方法判断出此时程序正在启动（各种单例初始化的过程中），再从这部分逻辑中找到performSelector:相关的代码逻辑，虽然不是最好的办法，但是通常通过这种方式可以把问题的查找方位逐渐缩小，提高找到问题原因的可能性。</p>

<h1 id="crash">常见Crash类型梳理（持续完善中…）</h1>
<blockquote>
  <p>之前每次查crash log都是查完就扔到一般，其实每种崩溃日志都有其特定的特点。下面列一些常见的Crash类型，也作为自己开发的经验积累，不断扩展中…</p>
</blockquote>

<ul>
  <li>内存问题 or 方法调用（调用高版本API、未知方法）</li>
  <li>数组越界</li>
  <li>多线程（mutable array）</li>
  <li>
    <p>unrecognized selector sent to instance （可能造成的原因：使用id指针、强制类型转换）</p>

    <pre><code>  id neverInit = [[Something alloc] init];
  [neverInit methodNotOwn];
</code></pre>
  </li>
  <li>
    <p>memory errors</p>

    <pre><code>  viewController.list = [NSArray arrayWithObjects:@"One", @"Two"];
</code></pre>
  </li>
  <li>Home键退后台后程序crash
    <ul>
      <li>在app处于后台时，ios是不允许app调opengl的</li>
      <li><a href="http://www.cnblogs.com/Clin/p/3405173.html">按Home键切换到后台后会触发libGPUSupportMercury.dylib: gpus_ReturnNotPermittedKillClient导致crash - Clin - 博客园</a></li>
      <li>应用占用内存过高（通常UIWebView会出现），推到后台直接被杀死</li>
    </ul>
  </li>
</ul>

<h1 id="llvm">LLVM的使用</h1>
<blockquote>
  <p>顺带记录一下调试过程中查到的一些LLVM实用技巧，后续有机会也都总结出来。
9. po $exa</p>
</blockquote>

<pre><code>	The po command stands for “print object.” The symbol $eax refers to one of the CPU registers. In the case of an exception, this register will contain a pointer to the NSException object. Note: $eax only works for the simulator, if you’re debugging on the device you’ll need to use register $r0.
</code></pre>

<h1 id="section-2">参考资料</h1>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/SIGSEGV">SIGSEGV - 维基百科，自由的百科全书</a></li>
  <li><a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE - cppreference.com</a></li>
  <li><a href="https://en.wikipedia.org/wiki/C_signal_handling">C signal handling - Wikipedia, the free encyclopedia</a></li>
  <li><a href="http://stackoverflow.com/questions/7446655/exception-types-in-ios-crash-logs">iphone - Exception Types in iOS crash logs - Stack Overflow</a>7.</li>
  <li><a href="http://www.raywenderlich.com/10209/my-app-crashed-now-what-part-1">My App Crashed, Now What? - Part 1 - Ray Wenderlich</a></li>
  <li><a href="http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs">Demystifying iOS Application Crash Logs - Ray Wenderlich</a></li>
  <li>sigaction: <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sigaction.2.html">Mac OS X Manual Page For sigaction(2)</a></li>
</ol>

<h1 id="my-question">My Question</h1>
<blockquote>
  <p>这次遇到的棘手问题也上传到了stackoverflow：</p>
</blockquote>

<ul>
  <li><a href="http://stackoverflow.com/questions/32480179/a-very-interesting-crash-log-with-exception-typeexc-crash-sigsegv">ios - A very interesting crash log with Exception Type:”EXC_CRASH (SIGSEGV)” - Stack Overflow</a></li>
</ul>

<h1 id="todos">TODOs</h1>
<ol>
  <li>Try Catch到的到底是什么？</li>
  <li>Mach Exceptions深入研究</li>
  <li>EXC_CRASH部分叫做Mach Exceptions，只有iOS和Mac才有，(SIGSEGV)是Unix Signal，所有基于Unix的系统都可以看到这样的符号？</li>
  <li>ARC(retain, release, weak, strong, assign, unsafe_retained)</li>
  <li>__kill 与 __pthread_kill 区别？</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习笔记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150907/gitxue-xi-bi-ji/"/>
    <updated>2015-09-07T17:58:21+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150907/gitxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h3 id="submodule">Submodule</h3>
<ul>
  <li><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html">Git Submodule使用完整教程 - 咖啡兔 - HenryYan</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调起协议测试页面]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150907/diao-qi-xie-yi-ce-shi-ye-mian/"/>
    <updated>2015-09-07T16:04:32+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150907/diao-qi-xie-yi-ce-shi-ye-mian</id>
    <content type="html"><![CDATA[<blockquote>
  <p>用于外部插件调起的测试页面</p>
</blockquote>

<ol>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fm.dianying.baidu.com%3Fldata%3D%257B%2522src_from%2522%253A%2522life_plus_icon%2522%257D%22%2C%22plugin_id%22%3A%22com.naplugin.movie%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.6.8.0">调起影票插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fm.nuomi.com%3Fn%3D1%26category%3Dgroupon%26cid%3Dbaidubox_old%26com_dispatch_param%3D%257B%2522ldata%2522%253A%2522%2522%252C%2522qid%2522%253A%2522%2522%252C%2522resid%2522%253A%2522%2522%252C%2522src_channel%2522%253A%2522kuang_life_hot_serve%2522%257D%26target%3Dtarget_wise_home%26box_citycode%3D131%22%2C%22plugin_id%22%3A%22lbsplugin.iphone.baidu.groupon%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.5.0.0">调起团购插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fmap.baidu.com%5C%2Fmobile%5C%2Fwebapp%5C%2Fplace%5C%2Fhotelzt%5C%2Ftest%3Dtest%26c%3D131%26hidenav%3D1%26hidefooter%3D1%26locMC%3D%7B%7BlocMC%7D%7D%26third_party%3Dkuang_service_hot_na%26cuid%3D15E7297BE1E69FF171C7AB4C15AD323F23F39C139ORQIDOKHNO%26resid%3D03%26com_dispatch_param%3D%7B%7D%26src_from%3Dkuang_service_hot_na%26category%3Dhotel%26target%3Dhotel_search_channel_wise%22%2C%22plugin_id%22%3A%22lbsplugin.iphone.baidu.hotel%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.5.0.0">调起酒店插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fwaimai.baidu.com%5C%2Fmobile%5C%2Fwaimai%3Fqt%3Dshoplist%26utm_source%3Dbaidu%26utm_medium%3Dbaidu_kuang%26utm_content%3Dkapian%26utm_term%3Ddefault%26utm_campaign%3Dkuang%26cid%3DWebAPP_%25E5%25A4%2596%25E5%258D%2596%25E6%258E%25A8%25E5%25B9%25BF_948162%26vmgdb%3D0020100222s%22%2C%22plugin_id%22%3A%22box.plugin.waimai%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.6.8.0">调起外卖插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22plugin_id%22%3A%22box.plugin.voicesearch%22%2C%22url%22%3A%22args%3Dsource_app%253Dbaiduboxapp%2526referer%253Dhome%22%7D&amp;minver=6.4.0.0">调起语音插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22plugin_id%22%3A%22box.plugin.imagesearch%22%2C%22url%22%3A%22args%3Dsource_app%253Dbaiduboxapp%2526referer%253Dhome%22%7D&amp;minver=6.4.0.0">调起图像搜索插件</a></li>
  <li><a href="baiduboxapp://browse?url=http%3a%2f%2fm.baidu.com&amp;minver=3.8.0.0">调起网页浏览</a></li>
  <li><a href="baiduboxapp://bdwallet?action=openCoupon&amp;params=&amp;func=&amp;minver=6.5.0.0">调起优惠券</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Blog List]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150831/ios-blog-list/"/>
    <updated>2015-08-31T17:35:48+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150831/ios-blog-list</id>
    <content type="html"><![CDATA[<blockquote>
  <p>还没来得及整理，各种途径搜集到的记录这里以后看。ps. 还是怀念greader时代啊。</p>
</blockquote>

<h3 id="ios">iOS</h3>
<ol>
  <li><a href="https://www.objc.io/">objc.io</a></li>
</ol>

<h3 id="section">图</h3>
<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/blog_list.png" alt="" /></p>

<h3 id="github">github</h3>
<ol>
  <li><a href="https://github.com/longv2go/iOSBlogCN">longv2go/iOSBlogCN</a></li>
</ol>

<h3 id="swift">Swift</h3>
<ol>
  <li><a href="http://swifter.tips/condition-compile/">Swifter - @ONECAT</a></li>
  <li><a href="http://natashatherobot.com/">Natasha The Robot</a></li>
  <li><a href="http://nshipster.cn/swift-objc-runtime/">Swift &amp; the Objective-C Runtime - NSHipster</a></li>
  <li><a href="https://developer.apple.com/swift/blog/">Swift Blog - Apple Developer</a></li>
</ol>

<h3 id="colleague">Colleague</h3>
<ol>
  <li><a href="http://blog.sunnyxx.com/">sunnyxx的技术博客</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wkwebview]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150826/wkwebview/"/>
    <updated>2015-08-26T15:53:26+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150826/wkwebview</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="http://nshipster.cn/wkwebkit/">WKWebView - NSHipster</a></p>

  <table>
    <tbody>
      <tr>
        <td>[WKWebView的新特性与使用</td>
        <td>发光的我](http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html)</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="wkwebkit-framework">WKWebKit Framework</h1>

<h1 id="nirtro-javascript">Nirtro JavaScript</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How can I find my passion【from Quaro】]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150819/how-can-i-find-my-passion/"/>
    <updated>2015-08-19T20:19:51+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150819/how-can-i-find-my-passion</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Quaro上Oliver Emberton大牛对这个问题的回答，觉得说的挺好，所以翻译了过来。
Oliver是Quaro上的知名答主，也是Silktide的创始人，
在他的<a href="http://oliveremberton.com/">Blog</a>上同样可以找到这篇回答。</p>
</blockquote>

<!--more-->

<p>  太多人相信一个有魔力的存在叫做“酷爱的事业”，“只要我找到我酷爱的事业”，人们总是说。“找到我酷爱的事业让我快乐”，人们如是说。</p>

<p class="center"><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Unicorn-12.png?imageView/2/w/500/q/90 =400x0" alt="" /></p>

<p>  酷爱的事业确实存在，同时也的确是一个强大的力量。但是几乎所有大家对于找到它的方法的认知，都是错误的！</p>

<h3 id="section">原则一、对某项事业的热忱来源于在其之上取得的成功</h3>

<p>  人类所有的情感之所以存在都有其合理性。饥饿感保证我们不会饿死，饱腹感保证我们不会撑死。<em>对事业的热忱
确保我们集中精力在最有回报的事情上。</em></p>

<p>  设想你开始上一堂舞蹈课，你发现这很简单。你意识到自己比别人跳得更好，学得更快。这时的兴奋度提升了你的热忱，这种热忱促使你回过头来投入到跳舞这项事业中，提升你的技能，增强你的力量。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-11.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  寻找“酷爱的事业”的路上有一个敌人叫挫折。如果自始至终一直努力挣扎着做好一件事，那么你永远不可能对它抱有热忱。你会学着放弃它，然后告诉自己：“我做不好这件事”。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-21.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  大多数人认为他们首先要发现“酷爱的事业”，然后自己再在其上取得成绩。实际上恰恰相反。<em>“Passion comes from success.”</em></p>

<h3 id="section-1">原则二、“酷爱的事业”早在童年就被扼杀了</h3>

<p>  理论上童年为我们提供了大量的机会去尝试各种事物，找到你的天赋，进而发现你“酷爱的事业”。
然而试想一下这个系统运行起来有多么的糟糕！比方说学校为你开设了20门课程，把你和其余上千名孩子一起排名。这样你的胜算很小。大部分的孩子被定义为“天赋平庸”。甚至于无论我们如何努力提高教学水平，因为我们<em>只有在感觉自己“天赋异禀”的领域才能找到自己“酷爱的事业”，而提高教学水平仅仅提高了“平庸”的标准。</em></p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Teacher2.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  即使你是这上千名孩子中幸运的一个，是这个初等数学班的第一名。教育系统将持续提高学习的难度知道你再次变得“平庸”——比如考上大学——在那儿你不再是那个对数学“天赋异禀”的孩子了。甚至于尽管你真的在这个领域非常非常棒，一旦你有了一点点“我和其他人做得差不多”的感觉，你对这项事业的热忱就悄悄的溜走了。</p>

<p>  再来说说你如果没那么幸运。万一你“酷爱的事业”是艺术呢？在人生的早期阶段对事业的热忱程度可能取决于它的社会重要程度。“画画儿能当饭吃啊？”，你的父亲告诉你。“你表哥搞计算机一个月挣老多钱了”，你的母亲这样说。于是你把“酷爱的事业”放在了一旁，任其慢慢凋谢。</p>

<p>  茫茫人海，很显然不可能所有人都擅长大学里面已开设的那几门课程。如果你真正擅长的是撰写演讲稿、创造性的舞蹈或者在Youtube上做游戏视频解说？课程表上甚至都没有这些东西。</p>

<p>于是，大部分人长大以后就没有“酷爱的事业”了。</p>

<h3 id="section-2">原则三、“酷爱的事业”可以被创造</h3>

<p>  你必须要了解一点，生活中最成功的人寻找自己“酷爱的事业”都不会像从书架上取书那么简单。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Careers-on-a-shelf2.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  实际上，最成功的人群中很多人都彻底的放弃了自己的学业。绝不是因为他们很笨，而是他们发现了<em>那些教育无法挖掘到的技能领域</em>。</p>

<p>  他们创造了属于自己的“酷爱的事业”！</p>

<p>  只有一小撮人能够在童年时提供给我们的那几门课程中找到兴奋点。在这个环境中的竞争范围基本上是“所有上学念书的人”。这大大降低了我们成功的几率。</p>

<p>  然而如果你能够跳出这个环境，你会发现更少的竞争，和更多的选择。这就是你提高发现自己“酷爱的事业”几率的方法。</p>

<h4 id="section-3">选择一、自己去创造</h4>

<p>  当你创造新领域的时候，很可能你就发明了一项你可以去“酷爱”的事业。</p>

<p>  你可以设计一款新奇的坐垫、撰写蝙蝠侠的故事，亦或是维护一个专门揭秘政客真实面貌的推特帐号。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Tweet.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  新领域相对来讲竞争很少的。通过创造新领域，可以大大提高使自己“天赋异禀”的几率。</p>

<p>  需要指出的一点是，创造新领域并不违背“原则一”（Passion comes from success）的约束。所以如果你的推特帐号在一年之后只有五个关注，这恐怕就不能成为你“酷爱的事业”。但如果有500万关注，你就可以辞掉你的工作了。<em>“You must find success to fuel your passion.”</em></p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-1-short.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  但至少你彻底地提高了成功的几率，因为竞争已经非常有限。只有一少部分人敢于尝试全新的东西。而你就是其中一个，仅仅是因为你敢于开始。</p>

<p>  你会发现这种模式在历史上已经得到了验证：一个叫做马克的学生以前没有成为世界上最Rock的程序员，直到他创建了一个非常酷的网站，而他发现自己非常擅长这件事情，因为<em>极少有人愿意尝试这件事情尽管他们程序写的更好</em>。事情就这样发生了，这个小小的尝试变成了Fackbook。</p>

<h4 id="section-4">选择二、引领新的潮流</h4>

<p>  越古老越确定的领域，竞争越激烈。无数先例已经证明了这一点，并且领先其他人的几率越小，找到“酷爱的事业”的几率就越小。</p>

<p>  但是总有先驱者降临，一个其他所有人都认为自己无能为力的领域，甚至于很简单的技巧也能让人印象深刻。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Emoticon-master.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  比方说你是一个2005年的时候做Youtube视频的年轻人。你拥有了一定量的粉丝，不断增长的成功激励着你。在那个时代飞速成长的互联网世界开始认识到YouTube是一个每天都有40亿用户访问的庞大王国，而你将这个极度有价值的新领域作为自己“酷爱的事业”。</p>

<p>  如果你能发掘那些成长迅速的新领域，并在早期获得相关的技能，你会发现如此容易的就胜过其他人，因为几乎没有竞争。这就是你所“酷爱的事业”。</p>

<h4 id="section-5">选择三、将多种平庸的才能融汇到一起</h4>

<p>  教育系统设计上的一个局限在于它不断的缩小你的能力范围。教育基本上是找到那个你“最擅长的事情”，然后不停的推进你坚持做这件事情：</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Education-progression.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  问题就是大多数的我们，广义上说，无法成为任何领域中最优秀的人。但是我们可以在我们能力组合之后的领域上取得领先。</p>

<p>  比如你是一个平庸的艺术家，但是有着非常好的幽默感。你估计不会在艺术领域取得很深的造诣，“幽默感”有无法成为一门学科。不过你可以成为一名非常棒的漫画家。</p>

<p>  再比如有一个资质平庸、学管理的学生，有一点编程经验和非常好的销售技巧。令人惊讶的是他非常适合当一个老板，尽管他管理的那些人在自己所在的领域都比这位老板更优秀。</p>

<p>  最成功的那些人几乎都不仅仅依赖一种技能，他们是各种技能的集合体，通常甚至没有特别出众的技能，但他们让自己这些<em>技能集合成的综合能力变得出众</em>。Steve Jobs不是世界上最优秀的工程师、销售员、设计师或者商人。但他是唯一一个在这些领域都足够优秀，将这些技能融会贯通使其走的更远的人。</p>

<p>  这是最后一个找到“酷爱的事业”的途径：<em>将多种平庸的才能融汇到一起使其更有价值</em>。记住，”Passion comes from success”. 如果这个新的融合让你取得了更好的结果，这就是你“酷爱的事业”所在。</p>

<h3 id="section-6">最后、为什么“酷爱的事业”很重要？</h3>

<p>  “酷爱的事业”的魅力在于：由于“酷爱的事业”是基于你相信自己在某个方面“天赋异禀”，做你“酷爱的事业”将成为一种很真实的方式去表达——“我是一个优秀的人”。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Awesome1.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  对事业的热忱将说服其他人追随你；将说服其他人信任你。最重要的是，这将说服你自己。热忱是一种情感促使你竭尽全力做好一件事情因为你的心告诉你做这件事会让你的世界更加精彩！和爱情一样值得去为之努力追逐。</p>

<p>  就像爱情一样，找到“酷爱的事业”如同命运的恩惠。如果你还没有找到属于你的“酷爱的事业”，尝试去创造，或者引领新的潮流，又或者将多种平庸的才能融汇成新的。但是一定不要停止你找寻的脚步！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift开发日记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150628/swiftkai-fa-ri-ji/"/>
    <updated>2015-06-28T17:48:09+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150628/swiftkai-fa-ri-ji</id>
    <content type="html"><![CDATA[<h3 id="section">博客站</h3>
<ol>
  <li><a href="http://swifter.tips/">Swifter - Swift 必备 tips</a></li>
  <li><a href="http://natashatherobot.com/">Natasha The Robot</a></li>
  <li><a href="http://nshipster.cn/swift-objc-runtime/">Swift &amp; the Objective-C Runtime - NSHipster</a></li>
  <li><a href="https://developer.apple.com/swift/blog/">Swift Blog - Apple Developer</a></li>
</ol>

<h3 id="section-1">开发技巧</h3>
<ol>
  <li>Prefer ‘let’</li>
  <li>string interpolation</li>
  <li>Inferred Typing</li>
  <li>any properties you declare must be set to an initial value when you declare them, or in your initializer</li>
  <li>命令行输入：lldb repl 调起 REPL(Read–Eval–Print Loop) ，推出命令：”:” -&gt; “quit”</li>
</ol>

<h3 id="swift">Swift特点</h3>
<ol>
  <li>编译型语言；</li>
  <li>LLVM；</li>
  <li>类型安全，同OC，变量和方法都有明确的返回，并且变量使用之前需要初始化；</li>
  <li>先进的语法体系：闭包、多返回、泛型、函数式编程理念；</li>
  <li>函数成为一种类型；</li>
  <li>Playground；</li>
  <li>iOS7及以上支持；</li>
</ol>

<h3 id="section-2">问题记录</h3>
<ol>
  <li>let 如何提高编译效率？</li>
  <li>如何做到 Inferred Typing</li>
  <li>继承：与NSObject对比</li>
  <li>动态类型（Runtime）</li>
  <li>为什么iOS6及以下不支持？</li>
</ol>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SIGABRT错误的调试办法]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150622/sigabrtcuo-wu-de-diao-shi-ban-fa/"/>
    <updated>2015-06-22T10:50:39+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150622/sigabrtcuo-wu-de-diao-shi-ban-fa</id>
    <content type="html"><![CDATA[<p>iOS经常会遇到一个头疼的error就是在main函数上显示“ Thread 1: signal SIGABRT ”这个错误，终于在stackoverflow上找到了调试的办法：</p>

<!--more-->

<p><a href="http://stackoverflow.com/questions/9782621/i-have-an-error-in-main-m-thread-1-signal-sigabrt-how-can-i-fix-this">Stackflow回答链接</a></p>

<p>重点就是 <strong>Set an exception breakpoint.</strong></p>

<p>之前我们遇到的在main函数上的那个崩溃信息，如果想要调试就加入一个 an exception breakpoint ，它会在exception 被 cathc 的时候停下来，这样就可以追踪到造成 exception 的代码了。</p>

<p>加入一个exception breakpoint的方法就是：在navigator的断点页面，点击左下角的加号就能看到 exception breakpoint；</p>

<p>加入的时候可以设置，默认是 all，也可以选择针对 oc 还是 c 的断点。</p>

<blockquote>
  <p>原文：</p>

  <p>When you get SIGABRT on that line of main, it means that your program is raising an exception. The stack trace shows where the exception is being caught, &gt;not where it’s being raised. Usually this is not helpful. To debug the problem, you can do two things:</p>

  <ol>
    <li>
      <p>Click the “Continue Program Execution” button in the debugger control bar, or choose Program &gt; Debug &gt; Continue from the menu bar. This will let the program continue the exception-raising process. It will print a message to the debugger console that will help you understand what’s wrong. (You may have &gt;to continue execution a couple of times before it actually prints messages.) Read the messages carefully! They usually continue helpful information.</p>
    </li>
    <li>
      <p>Set an exception breakpoint. This will make Xcode stop your program at the point where the exception is being raised, so you can see the code and the stack trace that is causing the problem.</p>
    </li>
  </ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch与Wax对比分析]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi/"/>
    <updated>2015-06-18T19:19:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="https://github.com/bang590/JSPatch">JSPatch</a>与<a href="https://github.com/probablycorey/wax">Wax</a>作为iOS平台上两大热更新框架使用不同的语言、基于相同的原理（ObjC动态绑定）一直备受iOS开发者的青睐，Wax出现较早且已经不再维护，但是也有了各种各样的分支版本；JSPatch作为后起之秀得益于iOS7苹果开放了JavascriptCore.framework的API，相比以前的Wax框架有了很多更新，下面就根据以往的开发经验简单比较一下二者的优势劣势，如果想对两个框架有更多的了解，请移步上文的官方网站和相关文档。</p>
</blockquote>

<!--more-->

<ol>
  <li>JSPatch相比于Wax的优势</li>
  <li>JSPatch相比于Wax的劣势</li>
</ol>

<hr />

<h1 id="jspatchwax">JSPatch相比于Wax的优势</h1>

<h2 id="section">内存管理</h2>
<ul>
  <li>JSPatch中JSValue负责维护被引用OC对象的生命周期，如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</li>
  <li>Wax在引用OC对象需要打上waxRetain标记，然后跑一个定时的GC查看这个对象的retainCount，当发现一个不再需要引用的对象retainCount大于1并且waxRetain为YES时（实际上的判断逻辑要复杂一些），就释放这个对象。依赖于retainCount，苹果官方是不推荐的，也不安全。</li>
</ul>

<h2 id="section-1">类型转换</h2>
<ul>
  <li>
    <p>JSPatch使用的是系统提供的类型转换，JSValue类内部可以看到完整的JS类型与OC的映射关系，同时支持NSArray和NSDictionary等类型的嵌套解析;</p>

    <pre><code>  @textblock
     Objective-C type  |   JavaScript type
   --------------------+---------------------
           nil         |     undefined
          NSNull       |        null
         NSString      |       string
         NSNumber      |   number, boolean
       NSDictionary    |   Object object
         NSArray       |    Array object
          NSDate       |     Date object
         NSBlock (1)   |   Function object (1)
            id (2)     |   Wrapper object (2)
          Class (3)    | Constructor object (3)
  @/textblock
</code></pre>
  </li>
  <li>
    <p>Lua中调用OC对象需要使用toobjc方法，否则会Crash，还有一个问题是NSDictionary、NSArray使用时是被copy的，也就是说你无法直接更改OC内存中的那个对象。</p>
  </li>
</ul>

<h2 id="section-2">多线程</h2>
<ul>
  <li>由于JSCore的支持，JS脚本实现的方法在多线程中调用没有任何问题，同时JSPatch也针对GCD提供了封装；</li>
  <li>Lua语言本身是不支持多线程的，多个线程同时调用Lua就等于同时操作同一张Lua元表，可能出问题；同时Wax调用异步的话只能依赖performSelectorInBackground:了。</li>
</ul>

<h2 id="block">Block</h2>
<ul>
  <li>JSPatch：天然支持，JS的Function类型会对应转换成NSBlock执行；</li>
  <li>个人认为Wax最受诟病的一点，无法支持Block使得方法替换和扩展都受到很大限制。</li>
</ul>

<h2 id="section-3">类型扩展</h2>
<ul>
  <li>JSPatch提供了CGRect、CGPoint、NSRange支持</li>
  <li>Lua调用OC对象时需要toobjc，NSDictionary、NSArray只支持copy，不支持retain</li>
</ul>

<h2 id="section-4">参数传递</h2>
<blockquote>
  <p>为了替换方法实现，将方法传递到脚本语言的实现过程中必须知道当前方法的参数类型列表，传统的方法是用va_list得到，但是arm64上va_list的实现更改无法根据内存位置取出参数，对于这个坑也是困了好久才解决。但是个人认为bang牛给了一个更好的解法。</p>
</blockquote>

<ul>
  <li>JSPatch为了解决arm64上va_list拿不到参数的问题，使用forwardInvocation方式，支持各种类型参数枚举；</li>
  <li>Wax框架维护期间还没有出现arm64所以也就一直平静的使用va_list，当然现在升级的话也可以使用JSPatch的这种方式；</li>
</ul>

<h1 id="jspatchwax-1">JSPatch相比于Wax的劣势</h1>

<h2 id="section-5">消息转发</h2>
<ul>
  <li>JS语言不支持消息转发，对于一个对象如果不响应方法就直接崩溃了，所以bang牛用正则替换了方法调用，然后通过桥接方法 __c() 来实现；</li>
  <li>Lua解析后的方法、变量都放到元表中，支持消息转发，算是一个非常好的特性。</li>
</ul>

<h2 id="ios6">iOS6支持</h2>
<ul>
  <li>JSPatch基于JSCore，仅支持iOS7+</li>
  <li>Wax理论上支持所有iOS版本。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch初探]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan/"/>
    <updated>2015-06-18T11:56:50+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan</id>
    <content type="html"><![CDATA[<hr />
<ol>
  <li>JSPatch是什么？</li>
  <li>Objective-C动态绑定机制</li>
  <li>JSPatch原理</li>
  <li>JSPatch实用举例</li>
  <li>与现有方案（Wax）的对比</li>
</ol>

<!--more-->

<hr />

<blockquote>
  <p><a href="http://blog.cnbang.net/tech/2808/">JSPatch实现原理详解</a></p>
</blockquote>

<h2 id="jspatch">一、JSPatch介绍</h2>
<blockquote>
  <p>最直观的介绍莫过于官方文档</p>
</blockquote>

<ul>
  <li><a href="https://github.com/bang590/JSPatch">bang590/JSPatch</a></li>
  <li>利用OC Runtime桥接Objective-C和JavaScript</li>
  <li>用处：
    <ul>
      <li>添加模块</li>
      <li>修复线上Bug</li>
    </ul>
  </li>
</ul>

<h2 id="oc">二、OC动态绑定机制</h2>
<blockquote>
  <p>一切iOS平台上实现动态BugFix和新增模块的技术都基于ObjC的动态绑定、动态加载、消息转发</p>
</blockquote>

<ul>
  <li>所谓动态绑定就是利用OC Runtime可以做如下几件事情：
    <ul>
      <li>给已有类增加方法</li>
      <li>替换现有类的方法指针，指向新的方法实现</li>
      <li>动态创建一个类</li>
    </ul>
  </li>
  <li>
    <p>【类对象】动态绑定机制源于OC的动态类实现</p>

    <pre><code>      #import &lt;objc/runtime.h&gt;
</code></pre>

    <ul>
      <li>除基本类型外所有OC类都继承于NSObject类</li>
      <li>NSObject对象有一个指向该实例所属类的isa指针</li>
      <li>OC中的类也是一个对象的概念，因此我们可以动态的创建一个类对象</li>
      <li>objc_allocateClassPair</li>
      <li>class_addMethod</li>
      <li>objc_registerClassPair</li>
    </ul>
  </li>
  <li>【消息】方法替换和新增源于消息转发机制
    <ul>
      <li>OC中方法调用起始是一个对象响应消息的过程</li>
      <li>可响应消息列表存在于对象isa指针所指向的类对象上</li>
      <li>objc_msgSend</li>
      <li>forwardInvocation:</li>
    </ul>
  </li>
</ul>

<h2 id="jspatch-1">三、JSPatch原理</h2>
<blockquote>
  <p>通过forwardInvocation方法，将</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150617/first-post/"/>
    <updated>2015-06-17T23:37:54+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150617/first-post</id>
    <content type="html"><![CDATA[<h3 id="first-postcnblog-">==== First Post下面是从cnblog迁移过来的旧文 ====</h3>

<p>以上是摘要部分
<!--more--></p>

<p> 段落开头</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">值</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">baseline</td>
      <td style="text-align: left">默认元素放置在父元素的基线上</td>
    </tr>
    <tr>
      <td style="text-align: left">sub</td>
      <td style="text-align: left">垂直对齐文本的下标</td>
    </tr>
    <tr>
      <td style="text-align: left">super</td>
      <td style="text-align: left">垂直对齐文本的上标</td>
    </tr>
    <tr>
      <td style="text-align: left">top</td>
      <td style="text-align: left">把元素的顶端与行中最高元素的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">text-top</td>
      <td style="text-align: left">把元素的顶端与父元素字体的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">middle</td>
      <td style="text-align: left">把此元素放置在父元素的中部</td>
    </tr>
    <tr>
      <td style="text-align: left">bottom</td>
      <td style="text-align: left">把元素的顶端与行中最低的元素的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">text-bottom</td>
      <td style="text-align: left">把元素的底端与父元素字体的底端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">length</td>
      <td style="text-align: left">相对基准线的偏移</td>
    </tr>
    <tr>
      <td style="text-align: left">%</td>
      <td style="text-align: left">使用 “line-height” 属性的百分比值来排列此元素允许使用负值</td>
    </tr>
    <tr>
      <td style="text-align: left">inherit</td>
      <td style="text-align: left">规定应该从父元素继承 vertical-align 属性的值<em>（所有的IE都不支持？！）</em></td>
    </tr>
  </tbody>
</table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步机制]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi/"/>
    <updated>2015-06-08T00:02:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi</id>
    <content type="html"><![CDATA[<blockquote>
  <ol>
    <li>及时响应用户</li>
    <li>实现多核调度</li>
  </ol>
</blockquote>

<!--more-->

<h3 id="nsoperation">NSOperation</h3>
<ol>
  <li>封装了大部分异步相关的逻辑，基础类，使用的时候要继承它创建我们自己的子类；</li>
  <li>系统实现的具体的类：NSInvocationOperation，NSBlockOperation；</li>
  <li>Dependency，Completion block，KVO，Priority，Cancel</li>
  <li>non-concurrent
    <ul>
      <li>重写main()</li>
      <li>autoreleasepool</li>
      <li>不需要自己维护状态</li>
    </ul>
  </li>
  <li>concurrent
    <ul>
      <li>实现start()</li>
      <li>实现异步操作</li>
      <li>自己维护isFinished，isExcuting，isCancelled（manual KVO）</li>
    </ul>
  </li>
  <li>判断是否cancel
    <ul>
      <li>main/start</li>
      <li>循环开始处</li>
      <li>逻辑区分点</li>
    </ul>
  </li>
</ol>

<h3 id="dispatch-queue">dispatch queue</h3>
<ol>
  <li>将业务逻辑写在block里
    <ul>
      <li>
        <p>定义：</p>

        <pre><code>  ^return type(params){expression}	
  typedef return type(^name)(params)
</code></pre>
      </li>
      <li>
        <p>声明：</p>

        <pre><code>  self.block = ^(params){expression};
</code></pre>
      </li>
      <li>
        <p>方法中定义的block在stack上，当调用copy时，会copy到heap上</p>
      </li>
    </ul>
  </li>
  <li>finalizer</li>
  <li>Serial(private dispatch queue)
    <ul>
      <li>block间顺序执行</li>
      <li>dispatch_queue_create()</li>
      <li>
        <p>需要自己维护reference count:</p>

        <pre><code>  dispatch_release()
</code></pre>
      </li>
    </ul>
  </li>
  <li>Concurrent(global dispatch queue)
    <ul>
      <li>block间并发执行</li>
      <li>dispatch_get_global_queue()</li>
      <li>normal, low, high</li>
      <li>系统维护reference count</li>
    </ul>
  </li>
  <li>main dispatch queue
    <ul>
      <li>在主线程run loop执行</li>
      <li>更新UI/主线程作为同步</li>
    </ul>
  </li>
  <li>dispatch queue维护自己的autoreleasepool</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImageView和UIButton拉伸效果的实现]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian/"/>
    <updated>2015-05-27T11:49:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>UIImageView中Image拉伸效果的实现：</p>

<pre><code>UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;
</code></pre>

<!--more-->

<p>但是虽然UIButton和UIImageView都是继承于UIView，但是二者实现方式不同，UIImageView没有subView，它 的content就是image，UIBotton不同，the way it works is a private implementation detail。</p>

<p>因此UIButton实现背景拉伸，即图片两端不拉伸中间拉伸的办法有如下两种：</p>

<p>第一种方法很简单而且使用性更广。做法就是直接拉伸想要setBackgroundImage的image，代码如下：</p>

<pre><code>UIImage*image =[UIImage imageNamed:@"image.png"];

image = [image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];

image =[image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];
</code></pre>

<p>设置了左端帽之后，rightCapWidth = image.size.width - (image.leftCapWidth + 1); 也就是说图片中间的一像素用来拉伸。垂直方向同上。</p>

<p>设置之后无论把image放到什么控件中都可以自动拉伸了。</p>

<p>第二种方法是在UIButton中加入一个UIImageView，拉伸imageView，然后将button的背景设为clearColor等等。把imageView放入button中，并且sendToBack，得到效果。</p>

<p>代码如下：</p>

<pre><code>//刚才imageView拉伸的代码

UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;

//把imageView放入button中，并设置为back


[temp_button addSubview:backgroundImageView];
[temp_button sendSubviewToBack:backgroundImageView];
[temp_button setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p>button不能设置背景图片，这样就可以实现拉伸的图片作为背景并且背景上可以放置title。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURLConnection的同步与异步]]></title>
    <link href="http://blog.oneboxapp.com/blog/20140627/nsurlconnectionde-tong-bu-yu-yi-bu/"/>
    <updated>2014-06-27T12:15:00+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20140627/nsurlconnectionde-tong-bu-yu-yi-bu</id>
    <content type="html"><![CDATA[<p>从这篇文章中收益良多：http://www.cocoabyss.com/foundation/nsurlconnection-synchronous-asynchronous/</p>

<p>写下体会：（时间所限，比较杂乱，见谅！）</p>

<!--more-->
<hr />
<p>NSURLConnection的同步发送就不用说了，很简单，上面链接也说了，</p>

<p>异步在iOS5之前都是作为一个非正式的协议出现的，默认initWithRequestxxx方法发送的就是异步请求，然后通过delegate中的方法可以操作，之前我一直错误在发送异步请求的时候也开一个新的线程，看了文章之后才想明白这真的是没有必要，在其他线程跑conn的原因就是为了避免阻塞主UI线程，而现在cocoa使用了delegate帮助你避免了这个问题，所以根本不需要再开一个新的线程去请求，直接请求然后在delegate中handleData就可以了。</p>

<p>而回到对同步conn的使用，同步conn使用我认为是一定要在新线程中，这样避免了阻塞主线程的缺点（如文中所说），但是相比与aSync conn，sync还有其他缺点，如不能在请求同时操作数据，不能cancel等等，所以还是aSync要好用。</p>

<hr />

<p>iOS4之前如果想在新的线程使用异步发送的conn，最好的方法应该就是文中教的trick，而</p>

<p>iOS5之后添加了 NSURLConnectionDataDelegate 把之前非正式协议的一部分拿了过来变成了正是协议（formal protocol），里面包括了数据处理等代理方法，还增加了在线程中发送异步请求的方法：</p>

<pre><code>+ (void)sendAsynchronousRequest:(NSURLRequest *)request

                          queue:(NSOperationQueue*) queue

              completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*)) handler NS_AVAILABLE(10_7, 5_0);
</code></pre>

<p>这样我认为就不需要像上文作者那样trick了吧？</p>

<p>***)
另外还加入了NSURLConnectionDownloadDelegate，主要作用就是讲数据直接存入文件中，缓存的时候估计有用吧？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于git分支的使用]]></title>
    <link href="http://blog.oneboxapp.com/blog/20140627/guan-yu-gitfen-zhi-de-shi-yong/"/>
    <updated>2014-06-27T11:48:12+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20140627/guan-yu-gitfen-zhi-de-shi-yong</id>
    <content type="html"><![CDATA[<p>学习记录，不正确的地方望指正！</p>

<!--more-->
<p>git branch 显示的是本地分支</p>

<p>git pull origin aRemoteBranch</p>

<p>git push origin aRemoteBranch</p>

<p>git commit 是提交到当前的本地分支</p>

<p>git remote显示远程服务器</p>

<p>git remote show aRemote显示指定的远程服务器（origin）上的远程分支</p>

<p>git checkout –track -b aLocalBranch aRemote/aRemoteBranch 创建一个新本地分支追踪远程分支（也可以直接 git checkout aRemoteBranch）</p>

<p>远程分支不可见，只能通过新建本地分支来追踪远程分支，本地分支和远程分支是两个不同的东西，也可以不同名。</p>

<p>checkout的时候会先检查本地分支，如果有则checkout到这个本地分支（不论它track哪个远程分支），如果没有则查看远程分支，如果有同名远程分支则新建一个本地同名分支并追踪（track）远程分支</p>

<p>git branch -d aLocalBranch  删除本地分支</p>

<p>git push ARemote :aRemoteBranch 删除远程分支</p>

<p>-d -&gt; -D 强制删除</p>

<p>vim .git/config</p>

<p>可以查看当前的remote和已经track了remote分支的本地分支</p>

<p>可以建多个本地分支track同一个远程分支，删除本地分支对远程分支没有影响。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APNs实现小记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20140627/apnsshi-xian-xiao-ji/"/>
    <updated>2014-06-27T11:07:51+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20140627/apnsshi-xian-xiao-ji</id>
    <content type="html"><![CDATA[<blockquote>
  <p>转自己以前写的博客，很早时候的学习笔记了，不过下面几个连接貌似都失效了。。。囧</p>
</blockquote>

<p>推荐如下链接，前两个介绍APNs的设置流程，已经很详尽，虽然很详尽但是个人感觉有些晦涩难懂，把简单的流程搞的复杂。我下面的内容是我设置APNs的过：</p>

<!--more-->
<p>[iPhone消息推送服务实现 - vber的专栏 - 博客频道 - CSDN.NET]</p>

<p>[apple push notification service apple与Python结合推送 - iOS开发讨论区 - Tiny4Cocoa]</p>

<table>
  <tbody>
    <tr>
      <td>[编写push notification之获取device token</td>
      <td>Marshal’s Blog]</td>
    </tr>
  </tbody>
</table>

<p><a href="http://slj.me/2010/02/iphone-push-notification/">偷窥iPhone Push Notification的幕后 - SLJ.me - 申力军</a></p>

<table>
  <tbody>
    <tr>
      <td>[iPhone的Push(推送通知)功能原理浅析 - iPhone/iPad 进阶讨论区 - 悦Phone论坛 iPhone</td>
      <td>iPad开发者、苹果开发者]</td>
    </tr>
  </tbody>
</table>

<p> 第一次接触APNs，鼓捣了一下午终于有了点眉目。</p>

<p> 链接1,2的流程介绍都是从最基础的入门级介绍，其实在你开发一款iOS app时，你需要做的是申请开发者帐号，设置Apple ID，生成provisioning file导入到Xcode，而APNs只是在设置Apple ID的时候多选择了一个选项，即Apple ID 的configure页面的 Enable for Apple Push Notification service选项，勾选它，然后根据你的需要生成dev或者release版本的SSL证书（证书生成的过程apple已经给了详尽的提示）。这里要注意的是，勾选了enable for apns之后，其实你的provisioning file已经改变，所以要重新下载新的导入Xcode。</p>

<hr />
<p>此时，你的app已经支持apns了。</p>

<p> 之后需要做的是两个方面：</p>

<ol>
  <li>
    <p>客户端 在appDelegate中编写代码，为了阅读方便就把上面链接中的代码重新贴一次：</p>

    <pre><code> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {  
   [[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |    UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];  
 }  
 - (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err {  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"Error in registration. Error: %@", err] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 }  
 - (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
   NSLog(@"devToken=%@",deviceToken);  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"devToken=%@",deviceToken] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 } 
</code></pre>
  </li>
</ol>

<p> 其实就是在appDidFinishLaunch的时候注册（register）apns，然后通过didRegisterForRemoteNotificationsWithDeviceToken得到DeviceToken。</p>

<p>接受服务器消息并改变客户端本地状态（如在app图表显示带数字的小红圈）的代码如下：</p>

<pre><code>	－(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
	
	    for (id key in userInfo) {
	        NSLog(@"key: %@, value: %@", key, [userInfo objectForKey:key]);
	    }    
	}
</code></pre>

<p> 到此为止，当你在真机上运行你的app时就会出现：是否允许app显示push notification的提示框。</p>

<ol>
  <li>服务器端 服务器端可以用PHP，Python等实现，网上也有一些现成的库如开源库APNSWrapper。现在你会发现我理解的思路跟链接1,2的介绍流程稍有不同，同时你会发现我还没有使用Enable for Apple Push Notification service时生成的证书文件，现在回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，关于这个文件要多说几句：</li>
</ol>

<blockquote>
  <p>这个文件的作用是让apple的APNs服务器确认服务器端具有push notification的权限。将这个证书作一定的处理（＊至于是什么处理为了不影响文章的连贯性会在下面介绍），生成一个ck.pem文件（这个名字可以自定义）。</p>
</blockquote>

<p> 然后就要涉及到APNs的工作机制，我的总结如下：当一个device（苹果设备）启用apns功能（就是通知功能）的时候会和apple的APNs服务器建立TLS连接，APNs服务器根据device的UDID和加密密钥新建一个DeviceToken（它的作用是让服务器端指定device，唯一）返回给device，然后device会把device token给你的app客户端，这时会调用刚才写的didRegisterForRemoteNotificationsWithDeviceToken方法，你可以在这个方法中将device token返回给服务器端。此后，如果服务器端push了一个notification给客户端，需要将这个device token和之前处理的ck.pem文件同时发送给APNs服务器，APNs服务器会验证你的ck.pem文件然后根据device token指定的设备推送消息给客户端）。当客户端接受到push的通知时调用didReceiveRemoteNotification方法，你可以在这个方法中放入你需要的操作。</p>

<blockquote>
  <p>现在再回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，对它的处理链接1,2都有介绍，就是：</p>
</blockquote>

<ol>
  <li>
    <p>选择“我的证书”, 选定推送服务证书(Apple Development Push Services*),导出到桌面,保存为Certificates.p12。</p>
  </li>
  <li>
    <p>在终端中运行如下命令:</p>

 	openssl pkcs12 -clcerts -nokeys -out cert.pem -in Certificates.p12<br />
 	openssl pkcs12 -nocerts -out key.pem -in Certificates.p12<br />
 	openssl rsa -in key.pem -out key.unencrypted.pem<br />
    <pre><code> 	cat cert.pem key.unencrypted.pem &gt; ck.pem  

 ck.pem文件则是PHP推送消息时所使用的证书文件。
</code></pre>
  </li>
</ol>

<p> 你剩下的任务就是编写服务器端的代码，push notification，这部分只要记住发送device token和证书文件就可以了。</p>

<p>（以上就是我理解学习APNs的过程，许多理解都不深入，所以描述也不准确，包涵～）</p>

<h2 id="section">更新：</h2>

<p><strong>开发中遇到的问题汇总</strong>：</p>

<ol>
  <li>
    <p>正常的iPhone刷系统之后，是没有设备证书和密钥的。这就是为什么iPhone会需要连接到 iTunes上进行激活——激活过程中，Apple会分配给每台iPhone独一无二的设备证书(device certificate)和密钥(key)。(如果没有意识到这个会一直收到 “未找到应用程序的”aps-environment” 的权利字符串)</p>
  </li>
  <li>
    <p>如果生成appleID的时候没有enable aps，那么enable之后一定要删掉原来的dev和rc证书重新生成，这样才能保证开启新功能，否则仅仅是刷新这张证书仍然会没有aps，提示（ “未找到应用程序的”aps-environment” 的权利字符串）</p>
  </li>
  <li>
    <p>APNs证书如果是系统证书那么最好拷贝到登陆证书中，这样可以直接导出成p12</p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java统计程序运行时间（转）]]></title>
    <link href="http://blog.oneboxapp.com/blog/20130627/javatong-ji-cheng-xu-yun-xing-shi-jian-(zhuan-)/"/>
    <updated>2013-06-27T12:05:57+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20130627/javatong-ji-cheng-xu-yun-xing-shi-jian-(zhuan-)</id>
    <content type="html"><![CDATA[<p>代码如下：
第一种是以毫秒为单位计算的。</p>

<pre><code>long startTime = System.currentTimeMillis();    //获取开始时间
</code></pre>

<!--more-->
<pre><code>doSomething();    //测试的代码段

long endTime = System.currentTimeMillis();    //获取结束时间

System.out.println("程序运行时间：" + (endTime - startTime) + "ms");    //输出程序运行时间
</code></pre>

<p>第二种是以纳秒为单位计算的。</p>

<pre><code>long startTime=System.nanoTime();   //获取开始时间  

doSomeThing(); //测试的代码段  

long endTime=System.nanoTime(); //获取结束时间  

System.out.println("程序运行时间： "+(endTime-startTime)+"ns"); 
</code></pre>

]]></content>
  </entry>
  
</feed>
