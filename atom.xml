<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[402]]></title>
  <link href="http://blog.oneboxapp.com/atom.xml" rel="self"/>
  <link href="http://blog.oneboxapp.com/"/>
  <updated>2015-10-12T17:05:50+08:00</updated>
  <id>http://blog.oneboxapp.com/</id>
  <author>
    <name><![CDATA[Kimimaro]]></name>
    <email><![CDATA[kimirius@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift的 ? 和 ! ]]></title>
    <link href="http://blog.oneboxapp.com/blog/20151010/swiftde-he/"/>
    <updated>2015-10-10T17:12:37+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20151010/swiftde-he</id>
    <content type="html"><![CDATA[<p>Swift语言中的常量变量的声明和使用方式借鉴了像Ruby这样的动态语言，也保留了静态语言的一些特性。</p>

<ul>
  <li>使用let定义常量</li>
  <li>使用var定义变量</li>
  <li><strong>普通值</strong>类型的变量声明之后不会赋默认值，必须初始化才能使用</li>
  <li>除普通值类型外，还可以声明<strong>Optional值</strong>类型的变量，也就是本文所讲的内容。</li>
</ul>

<p>Swift的常量变量使用中，Optional值理解起来是比较困难的，尤其是?和!这样的语法糖，代码写起来赏心悦目，但是学习起来就需要下点功夫。</p>

<blockquote>
  <p>?和!只是Optional值的语法糖，而!可以看做是?的进一步的特殊形式，所以后面说明的顺序是：Optional值 -&gt; ?语法糖 -&gt; !语法糖 -&gt; 使用注意事项</p>
</blockquote>

<!--more-->

<h3 id="optinal">什么是Optinal值（?语法糖）</h3>

<p>首先，我们来声明一个普通值的变量。</p>

<pre><code>var str : String
</code></pre>

<p>不给str赋初值，直接使用的话编译器会报错：</p>

<pre><code>// error: Variable 'str' used before being initialized
print(str)
</code></pre>

<p>如果我们这样定义，就没有问题了。</p>

<pre><code>var str2 : Optional&lt;String&gt;
		
// 通常我们使用?语法糖来实现上面的语法：
// var str2 : String?
		
print(str2)		// "nil\n"
</code></pre>

<p>“Optional&lt;String&gt;”就是一个Optional值，通过这个格式可以看出：Optional本身是一个枚举，&lt;String&gt;是这个枚举里面定义的一个泛型。</p>

<p>Optional在Swift2.0中的定义如下：</p>

<pre><code>public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible {
    case None
    case Some(Wrapped)
    /// Construct a `nil` instance.
    public init()
    /// Construct a non-`nil` instance that stores `some`.
    public init(_ some: Wrapped)
    /// If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`.
    @warn_unused_result
    @rethrows public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U?
    /// Returns `nil` if `self` is nil, `f(self!)` otherwise.
    @warn_unused_result
    @rethrows public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) rethrows -&gt; U?
    /// Create an instance initialized with `nil`.
    public init(nilLiteral: ())
}
</code></pre>

<p>通过上面的定义我们可以看到两个枚举类型：.None和.Some(Wrapped)。这样就很好理解了，声明的时候如果使用了?或者!，这个变量的类型就不简简单单是String类型，而是一个Optinal.Some<string>的枚举，因此也就解释了为什么对于这样的变量直接进行比较、属性访问、方法调用时编译器会报各种各样的错误。</string></p>

<h3 id="section">封装和拆包</h3>

<p>其实，<strong>Swift里面的nil就是Optional.None</strong>；非nil就是Optional.Some(Wrapped)，即变量里面存储的不是普通值（原始值），而是对原始值的<strong>封装（Wrap）</strong>，这也是Optional值类型变量在使用时需要先<strong>拆包(Unwrap)</strong>的原因。</p>

<p>因此 var str2 : Optional<string> 形式定义的变量，作为Optional值使用，例如用于比较、打印，可直接使用。</string></p>

<pre><code>// if (str2 != nil)
if (str2 != Optional.None) {    // 与上面意思相等
	...
}
</code></pre>

<p>这里强调一点是Swift2.0里面Optional值不能直接用作判断条件，必须和nil比较，如下的语句编译器会报错：</p>

<pre><code>// error: Optinal type cannot be used as a boolean.
// if str2 {
</code></pre>

<p>Optinal值还可以直接打印：</p>

<pre><code>print(str2)		// "nil\n"
</code></pre>

<h3 id="optinal-1">Optinal值的使用（拆包）</h3>

<p>如果要作为普通值使用，例如<strong>方法调用、属性访问、下标访问、打印原始值</strong>，则需要先拆包，再使用。由于Swift里面没有显示的拆包方法，因此需要通过?和!两个语法糖来实现。</p>

<ul>
  <li>
    <p>属性访问，?的作用可以理解为不是简单的拆包，而是先判断当前变量是否为nil，如果为nil，则忽略后续操作，如果不为nil，则执行后面的操作。</p>

    <pre><code>  str2?.capitalizedString		// nil
	
  // 此处由于在整个上下文中我还没有对str2赋值，所以编译器会报错
  // error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION
  // str2!.capitalizedString		
	
  str2 = "test"
  str2!.capitalizedString		// "Test"
</code></pre>
  </li>
  <li>
    <p>方法调用，在方法调用的时候?的作用类似于OC中的isResponseToSelector:，如果是nil则忽略后面的方法调用，如果非nil则执行方法调用。</p>

    <pre><code>  var str3 : String?
  str3 = "hello"
  print(str3)		// "Optional("hello")\n"
	
  str3?.appendContentsOf(" swift")
  print(str3)		// "Optional("hello swift")\n"
</code></pre>
  </li>
  <li>
    <p>下标访问</p>

    <pre><code>  var ary1 : Array&lt;Int&gt;?
	
  // 未经拆包访问下标编译器会报错
  // error: Cannot subscript a value from type 'Array&lt;Int&gt;?'
  // ary1[0]
	
  ary1?[0]	// nil
	
  ary1 = [1, 2, 3]
  ary1?[1]	// 2
</code></pre>
  </li>
  <li>
    <p>打印原始值，打印时不能用?号，Swift中?号只能用来访问属性、调用方法、访问下标元素。</p>

    <pre><code>  var str4 : String?
	
  // error: '?' must be followed by a call, member lookup, or subscript
  // print(str4?)
</code></pre>

    <p>只能用!打印Optional的原始值，当然，如果什么都不加，则打印的是原始值本身。</p>

    <pre><code>  str4 = "make a cup of tea"
  print(str4!)	// "make a cup of tea\n"
  print(str4)		// "Optional("make a cup of tea")\n"
</code></pre>

    <p>打印未主动初始化的Optinal值同样会报错。</p>

    <pre><code>  var str5 : String?
  // error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION
  // print(str5!)
</code></pre>
  </li>
</ul>

<p>以上就是?语法糖（即Optinal值）在变量声明和变量使用两个方面的用法，有了上面的基础，!语法糖可以简单总结为两句话：</p>

<h3 id="section-1">!语法糖</h3>

<ol>
  <li>
    <p>声明时指定!，则表示这个变量不仅是一个Optinal值，并被初始化为nil，而且这个Optinal值在使用的时候都会被编译器隐式的加上!，即强制拆包。</p>

    <pre><code> var str6 : String!
 str6 = "str6"
 print(str6)		// "str6\n"
</code></pre>

    <p>注意到上面打印出来的是拆包后的内容，而不是”Optinal(“str6”)\n”。</p>

    <p>隐式拆包的Optinal值（Implicitly Unwrapped Optionals）的调用方式可以有如下三种，当然通常我们使用的是第一种：</p>

    <pre><code> str6.capitalizedString		// "Str6"
 str6?.capitalizedString		// "Str6"
 str6!.capitalizedString		// "Str6"
</code></pre>

    <p>前面提到!只不过是一种语法糖，真正对应的其实是ImplicitlyUnwrappedOptional这种枚举类型，如下两种方式声明得到的结果是一样的：</p>

    <pre><code> // var str7 : String!
 var str7 : ImplicitlyUnwrappedOptional&lt;String&gt;
</code></pre>
  </li>
  <li>
    <p>使用时加上!号表示强制拆包，由于对隐式拆包的Optinal值强制拆包是没有意义的（虽然编译上没有报错），因此这里的强制拆包通常用于使用?声明的Optinal值。</p>

    <pre><code> var str8 : String?				
 str8 = "Swift"
	
 if (str8 != nil) {
     // if判断从逻辑上保证str8不为空，可以强制拆包
     str8!.appendContentsOf(" is fun")
 }
</code></pre>
  </li>
</ol>

<p>值得注意的是：对于nil强制拆包会导致Crash。因此<strong>!这个东西是把双刃剑</strong>，有过大型程序经验的同学都了解：今天的逻辑保证x不为空，不代表明天的逻辑还能保证x不为空。</p>

<h3 id="section-2">?和!用于类型转换</h3>

<p>?和!还有另一种用法就是用于类型转换，看下下面的例子。</p>

<pre><code>var anybody : AnyObject
anybody = "still a String"
</code></pre>

<p>如果要把AnyObject赋值给一个Optinal.Some<string>，则需要as后面跟上?来进行类型转换，?的作用是判断anybody是否为一个String，如果是则赋值给justTry，如果不是则justTry值为nil。</string></p>

<pre><code>var justTry : String?
justTry = anybody as? String	// "still a String"
</code></pre>

<p>如果要把AnyObject赋值给一个普通String，则需要as后面跟上!来强制类型转换，!的作用是强制转换并赋值给secondTry。</p>

<pre><code>var secondTry : String
secondTry = anybody as! String		// "still a String"
</code></pre>

<p>如果我们这里重新给anybody赋一个Int值，那么发现!转换编译器会报错，而?转换的结果为nil</p>

<pre><code>anybody = 1
// error: Execution was interrupted, reason: singal SIGABRT.
// let anotherTry = anybody as! String

let tryAgain = anybody as? String	// nil

// 不带?和!的转换同样会报错
//let failedTry = anybody as String
</code></pre>

<h3 id="section-3">小贴士</h3>

<ol>
  <li>在思考Optinal值的nil比较时突然想到既然普通值不能与nil比较，那么普通值如何判断是否为nil呢?再细一想是自己犯二了，普通值在声明的时候compile-time就保证了不会为空，自然也不需要判断；</li>
  <li>上面已经提到在Swift中，nil其实是一个枚举值Optional.None，还有一个有意思的值：Void，它其实是()，一个空元组；</li>
  <li>强制拆包（!）不要轻易使用，倒也还没想到必须使用的场景，不知道后续会不会出现关于这一点的开发规范；</li>
  <li>可以考虑Optinal值在定义的时候增加一个特殊的命名规范和普通值加以区分，虽然现在编译器给的错误提示挺全面，但是代码的可阅读性也需要考虑。</li>
</ol>

<h3 id="optional">什么时候需要Optional值</h3>

<ol>
  <li>属性的初始化操作不在声明时和init中进行时；</li>
  <li>对已定义的Optinal变量使用时；</li>
  <li>对变量做类型转换时；</li>
  <li>当然，任何想用的时候只要得到编译器的同意都可以用。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac开发日记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20151010/mackai-fa-ri-ji/"/>
    <updated>2015-10-10T00:38:39+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20151010/mackai-fa-ri-ji</id>
    <content type="html"><![CDATA[<h3 id="nscollectionview">NSCollectionView</h3>
<ol>
  <li>通过 collectonViewItem.representedObject 拿到当前item正在展示的model，在其中可以存储id，index等信息</li>
</ol>

<h3 id="nsarraycontroller">NSArrayController</h3>
<ol>
  <li>
    <p>reload内容</p>

    <pre><code> .rearrangeObjects()
</code></pre>
  </li>
  <li>
    <p><a href="http://www.jeepshoe.org/629425401.htm">NSCollectionView + NSArrayController 实战 - 教程网</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[离散学习效率的提高]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150923/chi-san-xue-xi-xiao-lu-de-ti-gao/"/>
    <updated>2015-09-23T16:15:30+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150923/chi-san-xue-xi-xiao-lu-de-ti-gao</id>
    <content type="html"><![CDATA[<blockquote>
  <p>随着年龄的增长，社交圈子的复杂化，在日常的工作生活中已经很难像学生时代那样，总是有大块的时间用来专注的做某一件事情，或者学某些东西，因此，<strong>离散时间里的学习效率就值得去重视起来</strong>，并且，离散学习效率的提高与集中时间学习效率提高的方法途径大不相同。</p>
</blockquote>

<h1 id="section">提前做准备</h1>
<!--more-->
<ol>
  <li>提前给短暂的空闲时间安排点事情，比如：背单词</li>
  <li>提前心绪不宁的时候安排点的时候安排点事情，比如：背单词</li>
  <li>保持良好的状态，参见：“如何治疗拖延症”</li>
  <li>如果发现大脑非常活跃在你不希望的领域上，尝试做些专注且消耗大脑养分的事情，比如：唱首歌</li>
</ol>

<h1 id="section-1">每天都要放平心态</h1>

<h1 id="section-2">每天都要记住持续学习</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有准备的人永远有机会]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150923/you-zhun-bei-de-ren-yong-yuan-you-ji-hui/"/>
    <updated>2015-09-23T16:15:08+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150923/you-zhun-bei-de-ren-yong-yuan-you-ji-hui</id>
    <content type="html"><![CDATA[<blockquote>
  <p>写给参加校招的应届毕业生。</p>
</blockquote>

<ul>
  <li>
    <p>不要迟到！！！</p>
  </li>
  <li>
    <p>编程题没有思路也要写代码。因为面试要求里面有一条是考察代码编写的能力，代码工整也是考察点之一，另外即使没有思路，异常情况考虑进来总是可以的吧。</p>
  </li>
  <li>
    <p>语言简洁不啰嗦</p>
  </li>
  <li>
    <p>及时提问</p>
  </li>
  <li>
    <p>有准备的人永远有机会</p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拖延症的治疗方法【from Quora】]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150917/tuo-yan-zheng-de-zhi-liao-fang-fa-%5B(from-quora)%5D/"/>
    <updated>2015-09-17T17:34:19+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150917/tuo-yan-zheng-de-zhi-liao-fang-fa-[(from-quora)]</id>
    <content type="html"><![CDATA[<p> Quora翻译第二弹，依然是来自<a href="https://www.quora.com/Oliver-Emberton">Oliver Emberton</a>的回答，这次的问题是：<a href="https://www.quora.com/How-can-I-stop-procrastinating-7">How can I stop procrastinating? - Quora</a>——咋能治治俺的拖延症？</p>

<blockquote>
  <p>刚开始OE给了一大段的很有意思、极其生动的铺垫。</p>
</blockquote>

<p><strong>我将要回答你的问题，但首先允许我花费两分钟时间通过一条卡通蛇来阐述一下人类文明这个事儿。</strong></p>

<p> 人们总是认为自己非常聪明。当然那些伟大的、极聪明的大脑让我们能切开原子、登上月球，然而，这个同样也是愚蠢的大脑让我们直到天黑也没法开始一项工作。
<!--more-->
 我们从原始人类进化而来，但是我们从未完全从他们的遗赠中蜕变出来。你认识大脑中那个聪明的、理性的，用于保持人类头脑清醒的部分吧？让我们把他叫做<strong>Albert</strong>，他住在我们的大脑中，而他的邻居，则是一个容易冲动的、幼小的爬行动物，一个叫做<strong>Rex</strong>的家伙。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-231e3cf0e3602dbec6620883d2679020.png?imageView/2/w/500/q/90" alt="" /></p>

<p> 你知道如果遇见一个前凸后翘的美女你没办法控制自己不去注意一下吧？那就是Rex，无论你多么努力也<em>无法将他彻底关掉</em>。他是你的本能、你的冲动、你的爱和你的恐惧。</p>

<p> 人们总是认为Albert才是“真正的自己”——我们大脑中清醒的部分。他是那个用于讲话、理性的部分。当我们决定去健身房或者开始写毕业论文的时候，是Albert做的决定。但是Albert是年老体衰、容易疲惫的，<em>通常都是处于关机状态</em>。</p>

<p> 于是你的大脑被困在了一个总是昏昏欲睡的老教授和一个仿佛精力无限的、容易冲动的小爬行动物之间相互斗争的围城里。同时你偏偏将掌舵的大权交给了那个小动物。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-6ab03ac71e155b68284e907bc3903027.png?imageView/2/w/500/q/90" alt="" /></p>

<p> Rex确实会听Albert的话。就像所有孩子一样，他大多数时间会听从Albert的指挥，只要他没有太强烈的反对。可是，如果Rex极其强烈的渴望冲到沙发上看<a href="http://www.bilibili.com/video/av1566692/">幸存者</a>、吃<a href="https://www.facebook.com/Cheetos">奇多</a>，那么十有八九你就会照着去做了。</p>

<p> 在我们周围，人类取得的那些难以置信的成就绝大多数归功于我们对大脑中那个Rex的培养教育，去掌控她、抚慰她、推到她。</p>

<p> 我们将许许多多这样的成就称之为“人类文明”。广泛的说食物和房屋占据了“文明”的很大一部分。还包括法律与正义、义务教育、娱乐、一夫一妻制等等。所有这些都是用来让Rex保持安静，好让Albert有时间和精力去做一些有意义的事情——像发现青霉素或者发明<a href="https://www.facebook.com/Cheetos">奇多</a>。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/main-qimg-d65915fb7e9b65537d5244ba8a41b2b5.png?imageView/2/w/500/q/90" alt="" /></p>

<p>现在，让我们回头来看看你的拖延症问题。</p>

<p> 你通过清醒的大脑做了一个明智的决定，却奇怪自己为什么没有坚持下来。真实的原因是你的日常决策者——Rex——还没有那么成熟。</p>

<p> 设想一下你不得不不断的说服一个小孩子按照你说的做事情。对于一些简单的事情他会听从你，假设你的权威性足够的情况下。比如你告诉他：“到吃晚饭的时间了”。可是假如是他不想做这件事情，可能就不会那么顺利了，这时你不得不耐下性子好言相劝：</p>

<blockquote>
  <p><strong>以下是OE交给你的治疗拖延症的方法</strong></p>
</blockquote>

<ul>
  <li><strong>忘掉逻辑</strong>。一旦你决定做一件事情，逻辑合理性无法帮到你。你内心的小爬行动物可以被取悦、被恐吓、被鼓励，但永远不会听你讲道理。</li>
  <li><strong>保持自己舒适</strong>。当你饥饿、疲惫或者不开心的时候，内心的小Rex就会造反了。如果不能照顾好你自己，Rex就会哭闹并拒绝你要求的一切事情。<strong>这正是她想要的</strong>，吃饭、睡觉、打豆豆。</li>
  <li><strong>赏罚分明</strong>。建立日常的、强制性的奖惩机制。如果你想要一个小孩儿吃蔬菜，就不要提前给他吃甜点。在成功的时候奖励你自己，在失败的时候给自己可以量性的惩罚。经典的案例就是将你的目标公布出去或者找一个团队一起努力——社交压力会影响Rex。</li>
  <li><strong>煽动自己</strong>。你的爬行动物大脑只对情感有反应。因此，保持自己紧张的、或者是有所畏惧的状态。有动机的谈话、电影或者文章都是很有效的途径，持续在一段时间内。我自己利用的是振奋人心的音乐（我最喜欢的歌单之一是<a href="http://open.spotify.com/user/oliveremberton/playlist/4ifk7EG0SLkV0En6s0ds7g">Music to conquer worlds by</a>）。想象一下完成这件事之后内心的喜悦，或者失败带来的恐惧。利用想象力使其生动起来以至于可以触动到你。我们用相同的技巧来教导小孩子：“说谎话鼻子会变长”或者“西瓜子吃进去肚子里会长西瓜”。</li>
  <li><strong>强迫开始</strong>。你要做的最重要的一件事就是开始。Rex大部分的本能是避免变化，一旦你确定开始做某件事情的时候Rex的本能就开始发生改变。只要有足够长的时间，你甚至可以说服Rex喜欢上他原来讨厌的事情。我们强迫孩子去上学、去上钢琴课并不是完全没有理由的。</li>
  <li><strong>清空你的周围</strong>。Rex是短视的，脑瓜儿也不是很灵活。如果他看到微信图标，他就会想去点它。这就好像在小孩子上床睡觉前给他看一下刚刚开始的精彩动画片。将你周遭的环境设计成远离干扰的：登出即时聊天工具、关掉通知、关掉邮件。将工作和找乐子的地方分离开，最好远离电脑（至少远离社交网络）。</li>
</ul>

<p> 一旦你知道自己在寻找什么，就能够开始认识这个模式并且控制他们。</p>

<p> 每个人的大脑中都有一个容易冲动的幼小的爬行动物，而且很不幸的是大脑的掌舵大权偏偏在她的手中。你需要能够成为一名好家长让他尽可能的按你说的去做，很好的服务于你。时刻记住谁在负责掌控你的思想。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoodBooks]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150916/goodbooks/"/>
    <updated>2015-09-16T20:37:37+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150916/goodbooks</id>
    <content type="html"><![CDATA[<h3 id="dev">Dev</h3>
<ul>
  <li><a href="https://www.gitbook.com/explore">Explore - GitBook</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS富文本组件的实现-CoreText vs TextKit]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150916/iosfu-wen-ben-zu-jian-de-shi-xian-coretext-vs-textkit/"/>
    <updated>2015-09-16T18:00:44+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150916/iosfu-wen-ben-zu-jian-de-shi-xian-coretext-vs-textkit</id>
    <content type="html"><![CDATA[<h1 id="ios">iOS富文本实现</h1>

<p> 在iOS7之前，系统展现文字的方式只有UILabel、UITextView这样的简单控件，如果要实现复杂的富文本展现，则需要开发者自己调用CoreText去实现，开发的复杂程度非常大。</p>

<p> iOS7之前最优秀的实现应该是开源项目：<a href="https://github.com/Cocoanetics/DTCoreText">Cocoanetics/DTCoreText</a>，通过解析HTML和CSS文件最终用CoreText绘制。（UIWebView应该不会有人用吧 = .=）基于JavascriptCore应该也可以解析渲染出元素丰富的界面，但是没有HTML和CSS来的直观。</p>

<h1 id="dtcoretext">DTCoreText</h1>
<blockquote>
  <p>有关这个项目bang神的blog写的很赞。</p>
</blockquote>

<ul>
  <li><a href="http://blog.cnbang.net/tech/2630/">iOS富文本组件的实现—DTCoreText源码解析 数据篇 « bang’s blog</a></li>
  <li><a href="http://blog.cnbang.net/tech/2729/">iOS富文本组件的实现—DTCoreText源码解析 渲染篇 « bang’s blog</a></li>
  <li>基于DTCoreText实现的富文本项目Demo演示</li>
</ul>

<h1 id="textkit">TextKit</h1>
<blockquote>
  <p>iOS7上终于等来了TextKit，有关的介绍和吐槽都在这里：</p>
</blockquote>

<ul>
  <li><a href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/">Getting to Know TextKit · objc.io</a></li>
</ul>

<h1 id="section">总结</h1>
<p> 综合来讲TextKit已经具备了富文本展现的一切必备功能：整段缩进、截断（加省略号）、连字符、对齐、文本样式、文本效果、图片视频附件，但就多媒体附件这一块似乎支持的还没有DTCoreText那么灵活，只能插入固定的类型而不是插入一个View。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Crash Log分析实战]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150914/crash-logfen-xi-shi-zhan/"/>
    <updated>2015-09-14T15:56:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150914/crash-logfen-xi-shi-zhan</id>
    <content type="html"><![CDATA[<blockquote>
  <p>事情的缘起是收到了一个用户的线上Crash反馈，QA无法复现，但是作为体量大开发质量又追求极致的应用通常还得解决这样的问题。</p>

  <p>通过各种努力终于拿到了用户的Crash Log，结果符号化后的崩溃线程堆栈里面竟然一条有用的信息都找不到，WTF！
<!--more-->
崩溃日志如下：（出于公司隐私考虑去掉了部分符号）</p>
</blockquote>

<pre><code>{"name":"XXXApp","bug_type":"109","os_version":"iPhone OS 7.1.1 (11D201)","bundleID":"com.xxx","version":"6.7.1.0 (6.7.1)","app_name":"XXXApp"}
Incident Identifier: EC2DC883-C0DB-4FD6-81FB-237626598366
CrashReporter Key:   d5c091bc35732df06fcaf41e5786833159b04ea5
Hardware Model:      iPhone5,2
Process:             XXXApp [1912]
Path:                /var/mobile/Applications/4E3E131C-5847-4B61-A0E0-D350830C1693/BaiduBoxApp.app/XXXApp
Identifier:          com.xxx
Version:             6.7.1.0 (6.7.1)
Code Type:           ARM (Native)
Parent Process:      launchd [1]

Date/Time:           2015-08-28 00:37:32.658 +0800
OS Version:          iOS 7.1.1 (11D201)
Report Version:      104

Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  0

Thread 0 Crashed:
0   libsystem_kernel.dylib        	0x39c636d8 __kill + 8
1   Foundation                    	0x2f901c1e __NSThreadPerformPerform + 382
2   CoreFoundation                	0x2eee3fec __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 12
3   CoreFoundation                	0x2eee34b2 __CFRunLoopDoSources0 + 202
4   CoreFoundation                	0x2eee1ca2 __CFRunLoopRun + 626
5   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
6   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
7   GraphicsServices              	0x33db96ce GSEventRunModal + 134
8   UIKit                         	0x317ab88c UIApplicationMain + 1132
9   BaiduBoxApp                   	0x0006d13e main (main.m:17)
10  libdyld.dylib                 	0x39badab4 start + 0

Thread 1:
0   libsystem_kernel.dylib        	0x39c51804 kevent64 + 24
1   libdispatch.dylib             	0x39ba0050 _dispatch_mgr_invoke + 228
2   libdispatch.dylib             	0x39b9a2de _dispatch_mgr_thread + 34

Thread 2 name:  com.apple.NSURLConnectionLoader
Thread 2:
0   libsystem_kernel.dylib        	0x39c51a50 mach_msg_trap + 20
1   libsystem_kernel.dylib        	0x39c51848 mach_msg + 36
2   CoreFoundation                	0x2eee3624 __CFRunLoopServiceMachPort + 152
3   CoreFoundation                	0x2eee1d44 __CFRunLoopRun + 788
4   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
5   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
6   Foundation                    	0x2f88c23c +[NSURLConnection(Loader) _resourceLoadLoop:] + 316
7   Foundation                    	0x2f901a0a __NSThread__main__ + 1058
8   libsystem_pthread.dylib       	0x39ccb956 _pthread_body + 138
9   libsystem_pthread.dylib       	0x39ccb8c6 _pthread_start + 98
10  libsystem_pthread.dylib       	0x39cc9ae4 thread_start + 4

Thread 3 name:  com.apple.CFSocket.private
Thread 3:
0   libsystem_kernel.dylib        	0x39c64434 __select + 20
1   CoreFoundation                	0x2eee751e __CFSocketManager + 482
2   libsystem_pthread.dylib       	0x39ccb956 _pthread_body + 138
3   libsystem_pthread.dylib       	0x39ccb8c6 _pthread_start + 98
4   libsystem_pthread.dylib       	0x39cc9ae4 thread_start + 4

...
</code></pre>

<blockquote>
  <p>于是只好把各种exception type和C signal分析了一遍，希望能找到一些蛛丝马迹。</p>
</blockquote>

<h1 id="crash-log">Crash Log分析实例</h1>

<h3 id="exccrash-sigsegv">1. 首先还是来看看 EXC_CRASH (SIGSEGV)</h3>

<p><strong>Crash Log分析的标准姿势</strong>一般是这样的：</p>

<ol>
  <li>在用户的Crash日志文件查看应用版本，找到发布版本时的Archive包；</li>
  <li>其实我们只需要Archive包中的.app文件或者dSYM文件，二者中的一个即可；</li>
  <li>符号化日志中的内存地址，符号化出来的日志文件中的地址会被转换成对应的代码及行数，<strong>符号化的方法</strong>有如下几种：
    <ul>
      <li>mdimport dSYM文件，步骤如下：
        <ol>
          <li>找到对应版本的dSYM文件</li>
          <li>
            <p>导入到Xcode中，注意要用绝对路径，运行代码：</p>

            <pre><code> mdimport /Users/kimimaro/Desktop/log/XXXAPP.app.dSYM/
</code></pre>
          </li>
          <li>在Xcode中运行Re-symbolicate后查看结果</li>
          <li>顺便吐槽一下新版Xcode越来越不好用，Xcode6还没找到从外部导入crash文件之后执行Re-symbolicate的方法。真机里面的crash log用Xcode打开后，Window -&gt; Devices -&gt; 找到对应设备 -&gt; View Device Logs -&gt; 右键对应Log条目 -&gt; Re-symbolicate。</li>
        </ol>
      </li>
      <li>利用symbolicatecrash工具（<strong>因为方便所以更为常用</strong>）
        <ol>
          <li>
            <p>找到Symbolicatecrash文件（Symbolicatecrash文件独立于Xcode，可以拷出来使用）;</p>

            <pre><code> /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/
</code></pre>

            <p>或运行如下命令找到</p>

            <pre><code> find /Applications/Xcode.app -name symbolicatecrash -type f
</code></pre>
          </li>
          <li>
            <p>用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起，将Crash文件也拷到当前文件夹里面;</p>

            <pre><code> cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash /Users/kimimaro/Desktop/crash
</code></pre>
          </li>
          <li>
            <p>终端中输入命令，命令格式：Symbolicatecrash + 崩溃日志 + APP对应的.dSYM文件 + &gt; + 输出到的文件;</p>

            <pre><code> Symbolicatecrash .crash .dSYM &gt; a.log
</code></pre>
          </li>
          <li>将终端完成以后，在crash文件夹里面会多出一个文件a.log，这个就是最终的文件，可以查看bug所在；</li>
          <li>
            <p>如果提示”DEVELOPER_DIR” is not defined;</p>

            <pre><code> 在终端中输入： export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer
</code></pre>
          </li>
        </ol>
      </li>
      <li>直接执行atos命令（symbolicatecrash里面也是用了这个工具）
        <ol>
          <li>
            <p>计算symbol address，iOS某个版本之后新的crash日志的地址计算方式发生了改变，所以需要我们先手动计算一下（当然也可以写脚本算哈~）</p>

            <pre><code> slide: 0x00001000 
 stack address: 0x0006da48 
 load address: 0x5c000
			
 symbol address = slide + stack address - load address = 00012a48
</code></pre>
          </li>
          <li>
            <p>找到symbol address对应的代码行</p>

            <pre><code> atos -arch [arch] -o [dwarf]   [address]
 eg. atos -arch armv7 -o Joke.app/Joke 00012a48
			
 atos命令的一些参数如下：atos -o EXECUTABLE -arch ARCHITECTURE -l LOAD_ADDRESS ADDRESS
</code></pre>
          </li>
          <li>
            <p>再啰嗦一句，如果依赖atos写脚本的话就用：</p>

            <pre><code> xcrun atos -arch armv7s -o [dwarf]   [address]
</code></pre>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p>在符号化后的日志中找到：</p>

    <pre><code> Triggered by Thread:  0
</code></pre>

    <p>根据所指示的找到崩溃的线程，然后happy happy的在里面找到崩溃的函数；</p>
  </li>
</ol>

<p> 但是往往当我们找到崩溃线程的时候发现不能happy的解Bug了，因为对应的线程里面竟然全都是系统调用，一个应用内调用的方法都没有，ORZ。</p>

<blockquote>
  <p>接下来的分析可能就根据对应问题不同分析的手段也不同，但是总得来说还是有一些规律可寻的。</p>
</blockquote>

<h3 id="exception-type--c-signle">2. Exception Type &amp; C signle</h3>

<p> 上面Log里面的可以找到这样两行：</p>

<pre><code>Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
</code></pre>

<p> 第一行是这个崩溃日志的类型，由”Mach Exception”（以”EXC_“开头的）和”UNIX Signal”（如 SIGSEGV, SIGBUS 等）两部分组成。对于某些exceptions，也会附加一个处理器特定的Exception Code / Exception Subtype，包含和exception有关的信息。比如：“EXC_BAD_ACCESS”下面经常会看到“KERN_INVALID_ADDRESS at 0x80000010”这样的exception code；“EXC_RESOURCE”下面会看到“WAKEUPS”这样的exception subtype。</p>

<p> <strong>Mach Exception常见的有如下几种：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Exception类型</th>
      <th style="text-align: left">描述</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">EXC_BAD_ACCESS</td>
      <td style="text-align: left">Bad Memory Access</td>
      <td>错误内存地址，访问的地址不存在或者当前进程没有权限都会报这个错。通常后面跟随的UNIX Signal是<strong>SIGBUS</strong>或者<strong>SIGSEGV</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_CRASH</td>
      <td style="text-align: left">Abnormal Exit</td>
      <td>通常跟随的UNIX Signal是<strong>SIGABRT</strong>，当前进程被系统检测到有异常行为而杀死</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_BREAKPOINT</td>
      <td style="text-align: left">Trace / breakpoint Trap</td>
      <td>通常跟随的UNIX Signal是<strong>SIGTRAP</strong>，一般来说代码中主动抛出异常时发生。</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_GUARD</td>
      <td style="text-align: left">Violated Guarded Resource Protection</td>
      <td>侵犯了被监视资源的安全性，比如：确定的文件描述</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_BAD_INSTRUCTION</td>
      <td style="text-align: left">Illegal Instruction</td>
      <td>非法或未定义的指令或操作数</td>
    </tr>
    <tr>
      <td style="text-align: left">EXC_RESOURCE</td>
      <td style="text-align: left">Resource Limit</td>
      <td>达到资源极限时的App Crash</td>
    </tr>
    <tr>
      <td style="text-align: left">00000020</td>
      <td style="text-align: left">Hexadecimal Exception Type</td>
      <td>非“OS内核”异常</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>完整的Mach Exception列表可以在<a href="http://fxr.watson.org/fxr/source/osfmk/mach/exception_types.h?v=xnu-2050.18.24">这里</a>的源代码文件（sys/osfmk/mach/exception_types.h）中找到。</p>
</blockquote>

<p> <strong>UNIX Signal常见的有如下几种：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">UNIX Signal</th>
      <th style="text-align: left">解释说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">SIGSEGV</td>
      <td style="text-align: left">访问了无效的内存地址，这个地址存在，但是当前进程没有权限访问它。<strong>属于硬件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGABRT</td>
      <td style="text-align: left">程序Crash，这个符号是由C函数abort()触发的。通常代表系统发现当前程序执行出错。<strong>属于软件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGBUS</td>
      <td style="text-align: left">访问了无效的内存地址，与SIGSEGV的区别是：SIGBUS表示内存地址不存在。<strong>属于硬件层错误</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">SIGTRAP</td>
      <td style="text-align: left">Debugger相关</td>
    </tr>
    <tr>
      <td style="text-align: left">SIGILL</td>
      <td style="text-align: left">尝试执行一个非法的、未知的、没有权限的指令</td>
    </tr>
  </tbody>
</table>

<p> 上面两个表格只能帮助理解区分，实际定位问题时需要更深入的理解。举个例子说，比如上述Crash Log实例中：</p>

<ol>
  <li>
    <p>EXC_CRASH</p>

    <ul>
      <li>EXC_CRASH is a mach exception that just means the application terminated abnormally. The parenthetical is the signal that caused the exception, in your case it’s SIGABRT which almost always means that you have an un-handled exception somewhere or you have some code that is calling abort() for some reason (again, generally the un-handled exception handler calls this in the end).</li>
      <li>可能导致问题的原因：
        <ul>
          <li>unrecognized selector</li>
        </ul>
      </li>
      <li>调试方法：
        <ul>
          <li>All Exception Point</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>EXC_BAD_ACCESS</p>

    <ul>
      <li>可能导致该问题的原因：
        <ul>
          <li>memory errors</li>
        </ul>
      </li>
      <li>调试方法：
        <ul>
          <li>NSZombie</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>SIGSEGV</p>

    <ul>
      <li>在POSIX兼容的平台上，SIGSEGV是当一个进程执行了一个无效的内存引用，或发生段错误时发送给它的信号。SIGSEGV的符号常量在头文件signal.h中定义。因为在不同平台上，信号数字可能变化，因此符号信号名被使用。通常，它是信号#11。</li>
      <li>SIG是信号名的通用前缀。SEGV是segmentation violation（段违例）的缩写。</li>
      <li>它會出現在當程式企圖存取CPU無法定址的記憶體區段時。</li>
      <li>可能导致该问题的原因：
        <ul>
          <li>引用released对象</li>
          <li>引用从未init的对象</li>
          <li>数组越界</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>SIGABRT</p>

    <ul>
      <li>软件层（系统层）的错误</li>
      <li>可能导致该问题的原因：
        <ul>
          <li>try to free the same memory twice</li>
          <li>raise Exception</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>结合Exception Type和UNIX Signal可以看出：</p>
    <ul>
      <li>这个Log中显示的崩溃是一种比较异常的情况：（Mach Exception Type和C signal常识上不匹配）；</li>
      <li>程序崩溃的原因比较大的可能仍是<strong>访问了无效的内存地址</strong>。</li>
    </ul>
  </li>
</ol>

<h3 id="section">3. 崩溃线程中的系统调用</h3>
<blockquote>
  <p>接着Exception Type部分往下看，程序崩溃在了Thread 0，那么我们就来看一下Thread 0的内存堆栈。</p>
</blockquote>

<p> 如上面所说崩溃线程中除了main.m方法属于App源码外，其他皆为系统调用。</p>

<pre><code>2   CoreFoundation                	0x2eee3fec __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 12
3   CoreFoundation                	0x2eee34b2 __CFRunLoopDoSources0 + 202
4   CoreFoundation                	0x2eee1ca2 __CFRunLoopRun + 626
5   CoreFoundation                	0x2ee4c764 CFRunLoopRunSpecific + 520
6   CoreFoundation                	0x2ee4c546 CFRunLoopRunInMode + 102
7   GraphicsServices              	0x33db96ce GSEventRunModal + 134
8   UIKit                         	0x317ab88c UIApplicationMain + 1132
</code></pre>

<p>上面这个部分的堆栈是很平常的系统调用堆栈，在main方法执行后通常都会看到它们。重点是再上面这一句：</p>

<pre><code>1   Foundation                    	0x2f901c1e __NSThreadPerformPerform + 382
</code></pre>

<p>这个方法告诉我们很大可能是<strong>在我们调用performSelector:系列方法时程序发生崩溃</strong>的。</p>

<pre><code>_NSThreadPerformPerform is used by the performSelector... family of methods. So look at your use of those methods. In particular, figure out if it's possible that you're asking an object to perform a selector that it doesn't support. That would throw an exception.
</code></pre>

<h3 id="section-1">4. 判断当前程序正在运行的时机</h3>
<blockquote>
  <p>其他线程虽然不是导致崩溃的线程，但是根据其他线程中的可识别代码，可以大致判断出当前程序所处于的时期（程序启动、程序运行期、前后台切换等等），缩小问题定位的范围。</p>
</blockquote>

<p> 在上述Crash Log例子中通过其他线程正在执行的方法判断出此时程序正在启动（各种单例初始化的过程中），再从这部分逻辑中找到performSelector:相关的代码逻辑，虽然不是最好的办法，但是通常通过这种方式可以把问题的查找方位逐渐缩小，提高找到问题原因的可能性。</p>

<h1 id="crash">常见Crash类型梳理（持续完善中…）</h1>
<blockquote>
  <p>之前每次查crash log都是查完就扔到一般，其实每种崩溃日志都有其特定的特点。下面列一些常见的Crash类型，也作为自己开发的经验积累，不断扩展中…</p>
</blockquote>

<ul>
  <li>内存问题 or 方法调用（调用高版本API、未知方法）</li>
  <li>数组越界</li>
  <li>多线程（mutable array）</li>
  <li>
    <p>unrecognized selector sent to instance （可能造成的原因：使用id指针、强制类型转换）</p>

    <pre><code>  id neverInit = [[Something alloc] init];
  [neverInit methodNotOwn];
</code></pre>
  </li>
  <li>
    <p>memory errors</p>

    <pre><code>  viewController.list = [NSArray arrayWithObjects:@"One", @"Two"];
</code></pre>
  </li>
  <li>Home键退后台后程序crash
    <ul>
      <li>在app处于后台时，ios是不允许app调opengl的</li>
      <li><a href="http://www.cnblogs.com/Clin/p/3405173.html">按Home键切换到后台后会触发libGPUSupportMercury.dylib: gpus_ReturnNotPermittedKillClient导致crash - Clin - 博客园</a></li>
      <li>应用占用内存过高（通常UIWebView会出现），推到后台直接被杀死</li>
    </ul>
  </li>
  <li>(null): unrecognized selector sent to instance 0xblah
    <ul>
      <li>一种特殊的找不到selector的crash</li>
      <li>http://grantech.blogspot.com/2010/12/error-null-unrecognized-selector-sent.html</li>
    </ul>
  </li>
</ul>

<h1 id="llvm">LLVM的使用</h1>
<blockquote>
  <p>顺带记录一下调试过程中查到的一些LLVM实用技巧，后续有机会也都总结出来。
9. po $exa</p>
</blockquote>

<pre><code>	The po command stands for “print object.” The symbol $eax refers to one of the CPU registers. In the case of an exception, this register will contain a pointer to the NSException object. Note: $eax only works for the simulator, if you’re debugging on the device you’ll need to use register $r0.
</code></pre>

<h1 id="section-2">参考资料</h1>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/SIGSEGV">SIGSEGV - 维基百科，自由的百科全书</a></li>
  <li><a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE - cppreference.com</a></li>
  <li><a href="https://en.wikipedia.org/wiki/C_signal_handling">C signal handling - Wikipedia, the free encyclopedia</a></li>
  <li><a href="http://stackoverflow.com/questions/7446655/exception-types-in-ios-crash-logs">iphone - Exception Types in iOS crash logs - Stack Overflow</a>7.</li>
  <li><a href="http://www.raywenderlich.com/10209/my-app-crashed-now-what-part-1">My App Crashed, Now What? - Part 1 - Ray Wenderlich</a></li>
  <li><a href="http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs">Demystifying iOS Application Crash Logs - Ray Wenderlich</a></li>
  <li>sigaction: <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sigaction.2.html">Mac OS X Manual Page For sigaction(2)</a></li>
</ol>

<h1 id="my-question">My Question</h1>
<blockquote>
  <p>这次遇到的棘手问题也上传到了stackoverflow：</p>
</blockquote>

<ul>
  <li><a href="http://stackoverflow.com/questions/32480179/a-very-interesting-crash-log-with-exception-typeexc-crash-sigsegv">ios - A very interesting crash log with Exception Type:”EXC_CRASH (SIGSEGV)” - Stack Overflow</a></li>
</ul>

<h1 id="todos">TODOs</h1>
<ol>
  <li>Try Catch到的到底是什么？</li>
  <li>Mach Exceptions深入研究</li>
  <li>EXC_CRASH部分叫做Mach Exceptions，只有iOS和Mac才有，(SIGSEGV)是Unix Signal，所有基于Unix的系统都可以看到这样的符号？</li>
  <li>ARC(retain, release, weak, strong, assign, unsafe_retained)</li>
  <li>__kill 与 __pthread_kill 区别？</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习笔记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150907/gitxue-xi-bi-ji/"/>
    <updated>2015-09-07T17:58:21+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150907/gitxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h3 id="submodule">Submodule</h3>
<ul>
  <li><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html">Git Submodule使用完整教程 - 咖啡兔 - HenryYan</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调起协议测试页面]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150907/diao-qi-xie-yi-ce-shi-ye-mian/"/>
    <updated>2015-09-07T16:04:32+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150907/diao-qi-xie-yi-ce-shi-ye-mian</id>
    <content type="html"><![CDATA[<blockquote>
  <p>用于外部插件调起的测试页面</p>
</blockquote>

<ol>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fm.dianying.baidu.com%3Fldata%3D%257B%2522src_from%2522%253A%2522life_plus_icon%2522%257D%22%2C%22plugin_id%22%3A%22com.naplugin.movie%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.6.8.0">调起影票插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fm.nuomi.com%3Fn%3D1%26category%3Dgroupon%26cid%3Dbaidubox_old%26com_dispatch_param%3D%257B%2522ldata%2522%253A%2522%2522%252C%2522qid%2522%253A%2522%2522%252C%2522resid%2522%253A%2522%2522%252C%2522src_channel%2522%253A%2522kuang_life_hot_serve%2522%257D%26target%3Dtarget_wise_home%26box_citycode%3D131%22%2C%22plugin_id%22%3A%22lbsplugin.iphone.baidu.groupon%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.5.0.0">调起团购插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fmap.baidu.com%5C%2Fmobile%5C%2Fwebapp%5C%2Fplace%5C%2Fhotelzt%5C%2Ftest%3Dtest%26c%3D131%26hidenav%3D1%26hidefooter%3D1%26locMC%3D%7B%7BlocMC%7D%7D%26third_party%3Dkuang_service_hot_na%26cuid%3D15E7297BE1E69FF171C7AB4C15AD323F23F39C139ORQIDOKHNO%26resid%3D03%26com_dispatch_param%3D%7B%7D%26src_from%3Dkuang_service_hot_na%26category%3Dhotel%26target%3Dhotel_search_channel_wise%22%2C%22plugin_id%22%3A%22lbsplugin.iphone.baidu.hotel%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.5.0.0">调起酒店插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fwaimai.baidu.com%5C%2Fmobile%5C%2Fwaimai%3Fqt%3Dshoplist%26utm_source%3Dbaidu%26utm_medium%3Dbaidu_kuang%26utm_content%3Dkapian%26utm_term%3Ddefault%26utm_campaign%3Dkuang%26cid%3DWebAPP_%25E5%25A4%2596%25E5%258D%2596%25E6%258E%25A8%25E5%25B9%25BF_948162%26vmgdb%3D0020100222s%22%2C%22plugin_id%22%3A%22box.plugin.waimai%22%2C%22log_url%22%3A%22%22%2C%22log_header%22%3A%22%22%7D&amp;minver=6.6.8.0">调起外卖插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22plugin_id%22%3A%22box.plugin.voicesearch%22%2C%22url%22%3A%22args%3Dsource_app%253Dbaiduboxapp%2526referer%253Dhome%22%7D&amp;minver=6.4.0.0">调起语音插件</a></li>
  <li><a href="baiduboxapp://invokePlug?action=open&amp;params=%7B%22plugin_id%22%3A%22box.plugin.imagesearch%22%2C%22url%22%3A%22args%3Dsource_app%253Dbaiduboxapp%2526referer%253Dhome%22%7D&amp;minver=6.4.0.0">调起图像搜索插件</a></li>
  <li><a href="baiduboxapp://browse?url=http%3a%2f%2fm.baidu.com&amp;minver=3.8.0.0">调起网页浏览</a></li>
  <li><a href="baiduboxapp://bdwallet?action=openCoupon&amp;params=&amp;func=&amp;minver=6.5.0.0">调起优惠券</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Blog List]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150831/ios-blog-list/"/>
    <updated>2015-08-31T17:35:48+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150831/ios-blog-list</id>
    <content type="html"><![CDATA[<blockquote>
  <p>还没来得及整理，各种途径搜集到的记录这里以后看。ps. 还是怀念greader时代啊。</p>
</blockquote>

<h3 id="ios">iOS</h3>
<ol>
  <li><a href="https://www.objc.io/">objc.io</a></li>
</ol>

<h3 id="section">图</h3>
<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/blog_list.png" alt="" /></p>

<h3 id="github">github</h3>
<ol>
  <li><a href="https://github.com/longv2go/iOSBlogCN">longv2go/iOSBlogCN</a></li>
</ol>

<h3 id="swift">Swift</h3>
<ol>
  <li><a href="http://swifter.tips/condition-compile/">Swifter - @ONECAT</a></li>
  <li><a href="http://natashatherobot.com/">Natasha The Robot</a></li>
  <li><a href="http://nshipster.cn/swift-objc-runtime/">Swift &amp; the Objective-C Runtime - NSHipster</a></li>
  <li><a href="https://developer.apple.com/swift/blog/">Swift Blog - Apple Developer</a></li>
</ol>

<h3 id="colleague">Colleague</h3>
<ol>
  <li><a href="http://blog.sunnyxx.com/">sunnyxx的技术博客</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wkwebview]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150826/wkwebview/"/>
    <updated>2015-08-26T15:53:26+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150826/wkwebview</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="http://nshipster.cn/wkwebkit/">WKWebView - NSHipster</a></p>

  <table>
    <tbody>
      <tr>
        <td>[WKWebView的新特性与使用</td>
        <td>发光的我](http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html)</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="wkwebkit-framework">WKWebKit Framework</h1>

<h1 id="nirtro-javascript">Nirtro JavaScript</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How can I find my passion【from Quaro】]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150819/how-can-i-find-my-passion/"/>
    <updated>2015-08-19T20:19:51+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150819/how-can-i-find-my-passion</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Quaro上Oliver Emberton大牛对这个问题的回答，觉得说的挺好，所以翻译了过来。
Oliver是Quaro上的知名答主，也是Silktide的创始人，
在他的<a href="http://oliveremberton.com/">Blog</a>上同样可以找到这篇回答。</p>
</blockquote>

<!--more-->

<p>  太多人相信一个有魔力的存在叫做“酷爱的事业”，“只要我找到我酷爱的事业”，人们总是说。“找到我酷爱的事业让我快乐”，人们如是说。</p>

<p class="center"><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Unicorn-12.png?imageView/2/w/500/q/90 =400x0" alt="" /></p>

<p>  酷爱的事业确实存在，同时也的确是一个强大的力量。但是几乎所有大家对于找到它的方法的认知，都是错误的！</p>

<h3 id="section">原则一、对某项事业的热忱来源于在其之上取得的成功</h3>

<p>  人类所有的情感之所以存在都有其合理性。饥饿感保证我们不会饿死，饱腹感保证我们不会撑死。<em>对事业的热忱
确保我们集中精力在最有回报的事情上。</em></p>

<p>  设想你开始上一堂舞蹈课，你发现这很简单。你意识到自己比别人跳得更好，学得更快。这时的兴奋度提升了你的热忱，这种热忱促使你回过头来投入到跳舞这项事业中，提升你的技能，增强你的力量。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-11.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  寻找“酷爱的事业”的路上有一个敌人叫挫折。如果自始至终一直努力挣扎着做好一件事，那么你永远不可能对它抱有热忱。你会学着放弃它，然后告诉自己：“我做不好这件事”。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-21.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  大多数人认为他们首先要发现“酷爱的事业”，然后自己再在其上取得成绩。实际上恰恰相反。<em>“Passion comes from success.”</em></p>

<h3 id="section-1">原则二、“酷爱的事业”早在童年就被扼杀了</h3>

<p>  理论上童年为我们提供了大量的机会去尝试各种事物，找到你的天赋，进而发现你“酷爱的事业”。
然而试想一下这个系统运行起来有多么的糟糕！比方说学校为你开设了20门课程，把你和其余上千名孩子一起排名。这样你的胜算很小。大部分的孩子被定义为“天赋平庸”。甚至于无论我们如何努力提高教学水平，因为我们<em>只有在感觉自己“天赋异禀”的领域才能找到自己“酷爱的事业”，而提高教学水平仅仅提高了“平庸”的标准。</em></p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Teacher2.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  即使你是这上千名孩子中幸运的一个，是这个初等数学班的第一名。教育系统将持续提高学习的难度知道你再次变得“平庸”——比如考上大学——在那儿你不再是那个对数学“天赋异禀”的孩子了。甚至于尽管你真的在这个领域非常非常棒，一旦你有了一点点“我和其他人做得差不多”的感觉，你对这项事业的热忱就悄悄的溜走了。</p>

<p>  再来说说你如果没那么幸运。万一你“酷爱的事业”是艺术呢？在人生的早期阶段对事业的热忱程度可能取决于它的社会重要程度。“画画儿能当饭吃啊？”，你的父亲告诉你。“你表哥搞计算机一个月挣老多钱了”，你的母亲这样说。于是你把“酷爱的事业”放在了一旁，任其慢慢凋谢。</p>

<p>  茫茫人海，很显然不可能所有人都擅长大学里面已开设的那几门课程。如果你真正擅长的是撰写演讲稿、创造性的舞蹈或者在Youtube上做游戏视频解说？课程表上甚至都没有这些东西。</p>

<p>于是，大部分人长大以后就没有“酷爱的事业”了。</p>

<h3 id="section-2">原则三、“酷爱的事业”可以被创造</h3>

<p>  你必须要了解一点，生活中最成功的人寻找自己“酷爱的事业”都不会像从书架上取书那么简单。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Careers-on-a-shelf2.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  实际上，最成功的人群中很多人都彻底的放弃了自己的学业。绝不是因为他们很笨，而是他们发现了<em>那些教育无法挖掘到的技能领域</em>。</p>

<p>  他们创造了属于自己的“酷爱的事业”！</p>

<p>  只有一小撮人能够在童年时提供给我们的那几门课程中找到兴奋点。在这个环境中的竞争范围基本上是“所有上学念书的人”。这大大降低了我们成功的几率。</p>

<p>  然而如果你能够跳出这个环境，你会发现更少的竞争，和更多的选择。这就是你提高发现自己“酷爱的事业”几率的方法。</p>

<h4 id="section-3">选择一、自己去创造</h4>

<p>  当你创造新领域的时候，很可能你就发明了一项你可以去“酷爱”的事业。</p>

<p>  你可以设计一款新奇的坐垫、撰写蝙蝠侠的故事，亦或是维护一个专门揭秘政客真实面貌的推特帐号。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Tweet.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  新领域相对来讲竞争很少的。通过创造新领域，可以大大提高使自己“天赋异禀”的几率。</p>

<p>  需要指出的一点是，创造新领域并不违背“原则一”（Passion comes from success）的约束。所以如果你的推特帐号在一年之后只有五个关注，这恐怕就不能成为你“酷爱的事业”。但如果有500万关注，你就可以辞掉你的工作了。<em>“You must find success to fuel your passion.”</em></p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Passion-cycle-1-short.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  但至少你彻底地提高了成功的几率，因为竞争已经非常有限。只有一少部分人敢于尝试全新的东西。而你就是其中一个，仅仅是因为你敢于开始。</p>

<p>  你会发现这种模式在历史上已经得到了验证：一个叫做马克的学生以前没有成为世界上最Rock的程序员，直到他创建了一个非常酷的网站，而他发现自己非常擅长这件事情，因为<em>极少有人愿意尝试这件事情尽管他们程序写的更好</em>。事情就这样发生了，这个小小的尝试变成了Fackbook。</p>

<h4 id="section-4">选择二、引领新的潮流</h4>

<p>  越古老越确定的领域，竞争越激烈。无数先例已经证明了这一点，并且领先其他人的几率越小，找到“酷爱的事业”的几率就越小。</p>

<p>  但是总有先驱者降临，一个其他所有人都认为自己无能为力的领域，甚至于很简单的技巧也能让人印象深刻。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Emoticon-master.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  比方说你是一个2005年的时候做Youtube视频的年轻人。你拥有了一定量的粉丝，不断增长的成功激励着你。在那个时代飞速成长的互联网世界开始认识到YouTube是一个每天都有40亿用户访问的庞大王国，而你将这个极度有价值的新领域作为自己“酷爱的事业”。</p>

<p>  如果你能发掘那些成长迅速的新领域，并在早期获得相关的技能，你会发现如此容易的就胜过其他人，因为几乎没有竞争。这就是你所“酷爱的事业”。</p>

<h4 id="section-5">选择三、将多种平庸的才能融汇到一起</h4>

<p>  教育系统设计上的一个局限在于它不断的缩小你的能力范围。教育基本上是找到那个你“最擅长的事情”，然后不停的推进你坚持做这件事情：</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Education-progression.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  问题就是大多数的我们，广义上说，无法成为任何领域中最优秀的人。但是我们可以在我们能力组合之后的领域上取得领先。</p>

<p>  比如你是一个平庸的艺术家，但是有着非常好的幽默感。你估计不会在艺术领域取得很深的造诣，“幽默感”有无法成为一门学科。不过你可以成为一名非常棒的漫画家。</p>

<p>  再比如有一个资质平庸、学管理的学生，有一点编程经验和非常好的销售技巧。令人惊讶的是他非常适合当一个老板，尽管他管理的那些人在自己所在的领域都比这位老板更优秀。</p>

<p>  最成功的那些人几乎都不仅仅依赖一种技能，他们是各种技能的集合体，通常甚至没有特别出众的技能，但他们让自己这些<em>技能集合成的综合能力变得出众</em>。Steve Jobs不是世界上最优秀的工程师、销售员、设计师或者商人。但他是唯一一个在这些领域都足够优秀，将这些技能融会贯通使其走的更远的人。</p>

<p>  这是最后一个找到“酷爱的事业”的途径：<em>将多种平庸的才能融汇到一起使其更有价值</em>。记住，”Passion comes from success”. 如果这个新的融合让你取得了更好的结果，这就是你“酷爱的事业”所在。</p>

<h3 id="section-6">最后、为什么“酷爱的事业”很重要？</h3>

<p>  “酷爱的事业”的魅力在于：由于“酷爱的事业”是基于你相信自己在某个方面“天赋异禀”，做你“酷爱的事业”将成为一种很真实的方式去表达——“我是一个优秀的人”。</p>

<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/Awesome1.png?imageView/2/w/500/q/90" alt="" /></p>

<p>  对事业的热忱将说服其他人追随你；将说服其他人信任你。最重要的是，这将说服你自己。热忱是一种情感促使你竭尽全力做好一件事情因为你的心告诉你做这件事会让你的世界更加精彩！和爱情一样值得去为之努力追逐。</p>

<p>  就像爱情一样，找到“酷爱的事业”如同命运的恩惠。如果你还没有找到属于你的“酷爱的事业”，尝试去创造，或者引领新的潮流，又或者将多种平庸的才能融汇成新的。但是一定不要停止你找寻的脚步！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift开发日记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150628/swiftkai-fa-ri-ji/"/>
    <updated>2015-06-28T17:48:09+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150628/swiftkai-fa-ri-ji</id>
    <content type="html"><![CDATA[<h3 id="enumeration">枚举（Enumeration）</h3>
<blockquote>
  <p><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/08_Enumerations.html">枚举（Enumerations） - The Swift Programming Language 中文版 - 极客学院Wiki</a></p>
</blockquote>

<ol>
  <li>
    <p>枚举的定义</p>

    <pre><code> enum CompassPoint {
     case North
     case South
     case East
     case West
 }
</code></pre>
  </li>
  <li>
    <p>枚举的使用</p>
    <ul>
      <li>
        <p>通过已定义枚举变量可以找到其枚举类型，因此在之后的赋值或控制流时可以忽略其枚举类型，直接以 . 开头</p>

        <pre><code>  var direction = CompassPoint.North
  switch direction {
  case .North:
  case .South:
  ...
  }
</code></pre>
      </li>
      <li>
        <p>如果控制流没有枚举出所有枚举值，则需要default语句，否则会报错</p>
      </li>
    </ul>
  </li>
</ol>

<!--more-->
<ol>
  <li>相关值
    <ul>
      <li>
        <p>即可以定义如下类型的枚举：</p>

        <pre><code>  enum Barcode {
      case UPCA(Int, Int, Int, Int )
      case QRCode(String)
  }
</code></pre>
      </li>
      <li>
        <p>赋值和使用方式如下：</p>

        <pre><code>  var product = Barcode.UPCA(8, 1111, 2222, 3)
  product = Barcode.QRCode("ABCDEFG")

  // 控制流
  switch product {
  case .UPCA(let numberSystem, let manufacturer, let product, let check):
  case let .QRCode(productCode):
  }
</code></pre>
      </li>
    </ul>
  </li>
  <li>
    <p>原始值的隐式赋值</p>

    <ul>
      <li>
        <p>首先定义枚举时可以给枚举值指定原始值</p>

        <pre><code>  enum ASCIIControlCharacter: Character {
      case Tab = "\t"
      case LineFeed = "\n"
      case CarriageReturn = "\r"
  }
</code></pre>
      </li>
      <li>
        <p>在使用原始值为整数或者字符串类型的枚举时，Swift会自动赋值。</p>
        <ul>
          <li>
            <p>Int类型隐式赋值为依次递增1，如果第一个值没有赋值，将会被自动置位0</p>

            <pre><code>  enum Planet: Int {
      // Mercury: 0, Venus: 1 ...
      case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
  }
</code></pre>
          </li>
          <li>
            <p>String类型隐式赋值则为该成员的名称</p>

            <pre><code>  enum CompassPoint: String {
      // North: "North", South: "South" ...
      case North, South, East, West
  }
</code></pre>
          </li>
          <li>
            <p>比如Alamofire里面有一段代码即为隐式赋值：</p>

            <pre><code>  public enum Method: String {
      case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
  }
</code></pre>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="section">函数</h3>
<ol>
  <li>
    <p>函数定义</p>

    <pre><code> func sayHello(personName: String) -&gt; String {
     let greeting = "Hello, " +  personName + "!"
     return greeting
 }
</code></pre>
  </li>
  <li>
    <p>函数名称</p>

    <pre><code> sayHello(_:)
</code></pre>
  </li>
  <li>多重输入参数&amp;多参量参数
    <ul>
      <li>
        <p>多重输入参数，参数类型相同，调用时不需要外部参数名</p>

        <pre><code>  func halfOpenRangeLength(start: Int, end: Int) -&gt; Int {
      return end - start
  }
  print(halfOpenRangeLength(1, 10))
  // prints "9"
</code></pre>
      </li>
      <li>
        <p>多参量参数</p>

        <pre><code>  func sayHello(personName: String, alreadyGreeted: String) -&gt; String {
      if alreadyGreeted {
          return "say hello again!"
      } else {
          return sayHello(personName)
      }
  }
  print(sayHello("Tim", alreadyGreeted: true))
  // prints "Hello again, Tim!"
</code></pre>
      </li>
      <li>
        <p>本地参数名称&amp;外部参数名称</p>
        <ul>
          <li>函数参数可以有一个本地参数名（用于函数内部实现）和一个外部参数名（用于函数调用）</li>
          <li>
            <p>一般来说，第一个参数忽略外部参数名，第二个参数起，外部参数名与其本地参数名相同</p>

            <pre><code>  func someFunction(firstParameterName: Int, secondParameterName: String) {
      ...
  }
  someFunction(1, secondParameterName: "two")
</code></pre>
          </li>
          <li>
            <p>如果要区分本地参数名和外部参数名，则外部参数名在前，而这以空格分隔。</p>

            <pre><code>  func sayHelloToBoth(to person: String, and anotherPerson: String) {
      ...
  }
  sayHelloToBoth(to: "Tom", and: "Jerry")
</code></pre>
          </li>
          <li>如果指定了外部参数名，则调用时必须使用外部参数名</li>
          <li>
            <p><strong>忽略外部参数名</strong>，如果不想为第二个及后续的参数设置外部参数名，可用一个下划线(_)代替</p>

            <pre><code>  func sayHelloToBoth(person: String, _ anotherPerson: String) {
      ...
  }
  sayHelloToBoth("Tom", "Jerry")
</code></pre>
          </li>
          <li>
            <p>默认参数值，如果给一个参数设置了默认参数值，则调用时可忽略这个参数，将带有默认值的参数放在函数参数列表的最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同的函数在不同情况下调用时显得更为清晰。</p>

            <pre><code>  func someFunction(parameterWithDefault: Int = 12) {
      // function body goes here
      // if no arguments are passed to the function call,
      // value of parameterWithDefault is 12
  }
  someFunction(6) // parameterWithDefault is 6
  someFunction() // parameterWithDefault is 12
</code></pre>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>返回值
    <ul>
      <li>无返回值函数
        <ul>
          <li>sayGoodbye(_:)</li>
          <li>可以省略返回值</li>
          <li>严格上来说，虽然没有返回值被定义，sayGoodbye(_:) 函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫 Void。它其实是一个空的元组（tuple），没有任何元素，可以写成()。</li>
        </ul>
      </li>
      <li>多返回值
        <ul>
          <li>
            <p>返回一个元组（注意：这个函数还体现了另一个语法，可变参数）</p>

            <pre><code>  func minMax(numbers: Int...) -&gt; (min: Int, max: Int) {
      ...
  }

  if let bounds = minMax(3, 4, 2, 6) {
      print("min is \(bounds.min), and max is \(bounds.max)")
  }
</code></pre>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>举个Alamofire中的函数例子说明：</p>

    <pre><code> public func request(
     method: Method,
     _ URLString: URLStringConvertible,
     parameters: [String: AnyObject]? = nil,
     encoding: ParameterEncoding = .URL,
     headers: [String: String]? = nil)
     -&gt; Request
 {
     return Manager.sharedInstance.request(
         method,
         URLString,
         parameters: parameters,
         encoding: encoding,
         headers: headers
     )
 }
</code></pre>

    <ul>
      <li>
        <p>调用时可以是这样：</p>

        <p>Alamofire.request(.GET, “http://private-f4f5c-onebox1.apiary-mock.com/questions/0”)</p>
      </li>
      <li>第一个参数method，默认忽略外部参数名</li>
      <li>第二个参数URLString，在函数声明时指定了忽略外部参数名</li>
      <li>第三、四、五个参数都指定了默认值，所以调用时可以直接不传外部参数</li>
      <li>另外，类似 [String: AnyObject]? 的定义标示参数类型是一个 Key为String类型，值是任意值的字典 或者 nil</li>
    </ul>
  </li>
  <li>notifications
    <ul>
      <li><a href="http://natashatherobot.com/ios8-where-to-remove-observer-for-nsnotification-in-swift/">iOS8: Where To Remove Observer for NSNotification in Swift</a></li>
    </ul>
  </li>
  <li>注意 [AnyObject] &amp; Array &amp; NSArray 间的区别</li>
  <li>selector
    <ul>
      <li>单纯用string来标示</li>
      <li><a href="http://stackoverflow.com/questions/24007650/selector-in-swift">@selector() in Swift? - Stack Overflow</a></li>
    </ul>
  </li>
</ol>

<h3 id="section-1">博客站</h3>
<ol>
  <li><a href="http://swifter.tips/">Swifter - Swift 必备 tips</a></li>
  <li><a href="http://natashatherobot.com/">Natasha The Robot</a></li>
  <li><a href="http://nshipster.cn/swift-objc-runtime/">Swift &amp; the Objective-C Runtime - NSHipster</a></li>
  <li><a href="https://developer.apple.com/swift/blog/">Swift Blog - Apple Developer</a></li>
</ol>

<h3 id="section-2">开发技巧</h3>
<ol>
  <li>Prefer ‘let’</li>
  <li>string interpolation</li>
  <li>Inferred Typing</li>
  <li>any properties you declare must be set to an initial value when you declare them, or in your initializer</li>
  <li>命令行输入：lldb repl 调起 REPL(Read–Eval–Print Loop) ，推出命令：”:” -&gt; “quit”</li>
</ol>

<h3 id="swift">Swift特点</h3>
<ol>
  <li>编译型语言；</li>
  <li>LLVM；</li>
  <li>类型安全，同OC，变量和方法都有明确的返回，并且变量使用之前需要初始化；</li>
  <li>先进的语法体系：闭包、多返回、泛型、函数式编程理念；</li>
  <li>函数成为一种类型；</li>
  <li>Playground；</li>
  <li>iOS7及以上支持；</li>
</ol>

<h3 id="section-3">问题记录</h3>
<ol>
  <li>let 如何提高编译效率？</li>
  <li>如何做到 Inferred Typing</li>
  <li>继承：与NSObject对比</li>
  <li>动态类型（Runtime）</li>
  <li>为什么iOS6及以下不支持？</li>
</ol>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SIGABRT错误的调试办法]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150622/sigabrtcuo-wu-de-diao-shi-ban-fa/"/>
    <updated>2015-06-22T10:50:39+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150622/sigabrtcuo-wu-de-diao-shi-ban-fa</id>
    <content type="html"><![CDATA[<p>iOS经常会遇到一个头疼的error就是在main函数上显示“ Thread 1: signal SIGABRT ”这个错误，终于在stackoverflow上找到了调试的办法：</p>

<!--more-->

<p><a href="http://stackoverflow.com/questions/9782621/i-have-an-error-in-main-m-thread-1-signal-sigabrt-how-can-i-fix-this">Stackflow回答链接</a></p>

<p>重点就是 <strong>Set an exception breakpoint.</strong></p>

<p>之前我们遇到的在main函数上的那个崩溃信息，如果想要调试就加入一个 an exception breakpoint ，它会在exception 被 cathc 的时候停下来，这样就可以追踪到造成 exception 的代码了。</p>

<p>加入一个exception breakpoint的方法就是：在navigator的断点页面，点击左下角的加号就能看到 exception breakpoint；</p>

<p>加入的时候可以设置，默认是 all，也可以选择针对 oc 还是 c 的断点。</p>

<blockquote>
  <p>原文：</p>

  <p>When you get SIGABRT on that line of main, it means that your program is raising an exception. The stack trace shows where the exception is being caught, &gt;not where it’s being raised. Usually this is not helpful. To debug the problem, you can do two things:</p>

  <ol>
    <li>
      <p>Click the “Continue Program Execution” button in the debugger control bar, or choose Program &gt; Debug &gt; Continue from the menu bar. This will let the program continue the exception-raising process. It will print a message to the debugger console that will help you understand what’s wrong. (You may have &gt;to continue execution a couple of times before it actually prints messages.) Read the messages carefully! They usually continue helpful information.</p>
    </li>
    <li>
      <p>Set an exception breakpoint. This will make Xcode stop your program at the point where the exception is being raised, so you can see the code and the stack trace that is causing the problem.</p>
    </li>
  </ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch与Wax对比分析]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi/"/>
    <updated>2015-06-18T19:19:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="https://github.com/bang590/JSPatch">JSPatch</a>与<a href="https://github.com/probablycorey/wax">Wax</a>作为iOS平台上两大热更新框架使用不同的语言、基于相同的原理（ObjC动态绑定）一直备受iOS开发者的青睐，Wax出现较早且已经不再维护，但是也有了各种各样的分支版本；JSPatch作为后起之秀得益于iOS7苹果开放了JavascriptCore.framework的API，相比以前的Wax框架有了很多更新，下面就根据以往的开发经验简单比较一下二者的优势劣势，如果想对两个框架有更多的了解，请移步上文的官方网站和相关文档。</p>
</blockquote>

<!--more-->

<ol>
  <li>JSPatch相比于Wax的优势</li>
  <li>JSPatch相比于Wax的劣势</li>
</ol>

<hr />

<h1 id="jspatchwax">JSPatch相比于Wax的优势</h1>

<h2 id="section">内存管理</h2>
<ul>
  <li>JSPatch中JSValue负责维护被引用OC对象的生命周期，如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</li>
  <li>Wax在引用OC对象需要打上waxRetain标记，然后跑一个定时的GC查看这个对象的retainCount，当发现一个不再需要引用的对象retainCount大于1并且waxRetain为YES时（实际上的判断逻辑要复杂一些），就释放这个对象。依赖于retainCount，苹果官方是不推荐的，也不安全。</li>
</ul>

<h2 id="section-1">类型转换</h2>
<ul>
  <li>
    <p>JSPatch使用的是系统提供的类型转换，JSValue类内部可以看到完整的JS类型与OC的映射关系，同时支持NSArray和NSDictionary等类型的嵌套解析;</p>

    <pre><code>  @textblock
     Objective-C type  |   JavaScript type
   --------------------+---------------------
           nil         |     undefined
          NSNull       |        null
         NSString      |       string
         NSNumber      |   number, boolean
       NSDictionary    |   Object object
         NSArray       |    Array object
          NSDate       |     Date object
         NSBlock (1)   |   Function object (1)
            id (2)     |   Wrapper object (2)
          Class (3)    | Constructor object (3)
  @/textblock
</code></pre>
  </li>
  <li>
    <p>Lua中调用OC对象需要使用toobjc方法，否则会Crash，还有一个问题是NSDictionary、NSArray使用时是被copy的，也就是说你无法直接更改OC内存中的那个对象。</p>
  </li>
</ul>

<h2 id="section-2">多线程</h2>
<ul>
  <li>由于JSCore的支持，JS脚本实现的方法在多线程中调用没有任何问题，同时JSPatch也针对GCD提供了封装；</li>
  <li>Lua语言本身是不支持多线程的，多个线程同时调用Lua就等于同时操作同一张Lua元表，可能出问题；同时Wax调用异步的话只能依赖performSelectorInBackground:了。</li>
</ul>

<h2 id="block">Block</h2>
<ul>
  <li>JSPatch：天然支持，JS的Function类型会对应转换成NSBlock执行；</li>
  <li>个人认为Wax最受诟病的一点，无法支持Block使得方法替换和扩展都受到很大限制。</li>
</ul>

<h2 id="section-3">类型扩展</h2>
<ul>
  <li>JSPatch提供了CGRect、CGPoint、NSRange支持</li>
  <li>Lua调用OC对象时需要toobjc，NSDictionary、NSArray只支持copy，不支持retain</li>
</ul>

<h2 id="section-4">参数传递</h2>
<blockquote>
  <p>为了替换方法实现，将方法传递到脚本语言的实现过程中必须知道当前方法的参数类型列表，传统的方法是用va_list得到，但是arm64上va_list的实现更改无法根据内存位置取出参数，对于这个坑也是困了好久才解决。但是个人认为bang牛给了一个更好的解法。</p>
</blockquote>

<ul>
  <li>JSPatch为了解决arm64上va_list拿不到参数的问题，使用forwardInvocation方式，支持各种类型参数枚举；</li>
  <li>Wax框架维护期间还没有出现arm64所以也就一直平静的使用va_list，当然现在升级的话也可以使用JSPatch的这种方式；</li>
</ul>

<h1 id="jspatchwax-1">JSPatch相比于Wax的劣势</h1>

<h2 id="section-5">消息转发</h2>
<ul>
  <li>JS语言不支持消息转发，对于一个对象如果不响应方法就直接崩溃了，所以bang牛用正则替换了方法调用，然后通过桥接方法 __c() 来实现；</li>
  <li>Lua解析后的方法、变量都放到元表中，支持消息转发，算是一个非常好的特性。</li>
</ul>

<h2 id="ios6">iOS6支持</h2>
<ul>
  <li>JSPatch基于JSCore，仅支持iOS7+</li>
  <li>Wax理论上支持所有iOS版本。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch初探]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan/"/>
    <updated>2015-06-18T11:56:50+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan</id>
    <content type="html"><![CDATA[<hr />
<ol>
  <li>JSPatch是什么？</li>
  <li>Objective-C动态绑定机制</li>
  <li>JSPatch原理</li>
  <li>JSPatch实用举例</li>
  <li>与现有方案（Wax）的对比</li>
</ol>

<!--more-->

<hr />

<blockquote>
  <p><a href="http://blog.cnbang.net/tech/2808/">JSPatch实现原理详解</a></p>
</blockquote>

<h2 id="jspatch">一、JSPatch介绍</h2>
<blockquote>
  <p>最直观的介绍莫过于官方文档</p>
</blockquote>

<ul>
  <li><a href="https://github.com/bang590/JSPatch">bang590/JSPatch</a></li>
  <li>利用OC Runtime桥接Objective-C和JavaScript</li>
  <li>用处：
    <ul>
      <li>添加模块</li>
      <li>修复线上Bug</li>
    </ul>
  </li>
</ul>

<h2 id="oc">二、OC动态绑定机制</h2>
<blockquote>
  <p>一切iOS平台上实现动态BugFix和新增模块的技术都基于ObjC的动态绑定、动态加载、消息转发</p>
</blockquote>

<ul>
  <li>所谓动态绑定就是利用OC Runtime可以做如下几件事情：
    <ul>
      <li>给已有类增加方法</li>
      <li>替换现有类的方法指针，指向新的方法实现</li>
      <li>动态创建一个类</li>
    </ul>
  </li>
  <li>
    <p>【类对象】动态绑定机制源于OC的动态类实现</p>

    <pre><code>      #import &lt;objc/runtime.h&gt;
</code></pre>

    <ul>
      <li>除基本类型外所有OC类都继承于NSObject类</li>
      <li>NSObject对象有一个指向该实例所属类的isa指针</li>
      <li>OC中的类也是一个对象的概念，因此我们可以动态的创建一个类对象</li>
      <li>objc_allocateClassPair</li>
      <li>class_addMethod</li>
      <li>objc_registerClassPair</li>
    </ul>
  </li>
  <li>【消息】方法替换和新增源于消息转发机制
    <ul>
      <li>OC中方法调用起始是一个对象响应消息的过程</li>
      <li>可响应消息列表存在于对象isa指针所指向的类对象上</li>
      <li>objc_msgSend</li>
      <li>forwardInvocation:</li>
    </ul>
  </li>
</ul>

<h2 id="jspatch-1">三、JSPatch原理</h2>
<blockquote>
  <p>通过forwardInvocation方法，将</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150617/first-post/"/>
    <updated>2015-06-17T23:37:54+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150617/first-post</id>
    <content type="html"><![CDATA[<h3 id="first-postcnblog-">==== First Post下面是从cnblog迁移过来的旧文 ====</h3>

<p>以上是摘要部分
<!--more--></p>

<p> 段落开头</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">值</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">baseline</td>
      <td style="text-align: left">默认元素放置在父元素的基线上</td>
    </tr>
    <tr>
      <td style="text-align: left">sub</td>
      <td style="text-align: left">垂直对齐文本的下标</td>
    </tr>
    <tr>
      <td style="text-align: left">super</td>
      <td style="text-align: left">垂直对齐文本的上标</td>
    </tr>
    <tr>
      <td style="text-align: left">top</td>
      <td style="text-align: left">把元素的顶端与行中最高元素的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">text-top</td>
      <td style="text-align: left">把元素的顶端与父元素字体的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">middle</td>
      <td style="text-align: left">把此元素放置在父元素的中部</td>
    </tr>
    <tr>
      <td style="text-align: left">bottom</td>
      <td style="text-align: left">把元素的顶端与行中最低的元素的顶端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">text-bottom</td>
      <td style="text-align: left">把元素的底端与父元素字体的底端对齐</td>
    </tr>
    <tr>
      <td style="text-align: left">length</td>
      <td style="text-align: left">相对基准线的偏移</td>
    </tr>
    <tr>
      <td style="text-align: left">%</td>
      <td style="text-align: left">使用 “line-height” 属性的百分比值来排列此元素允许使用负值</td>
    </tr>
    <tr>
      <td style="text-align: left">inherit</td>
      <td style="text-align: left">规定应该从父元素继承 vertical-align 属性的值<em>（所有的IE都不支持？！）</em></td>
    </tr>
  </tbody>
</table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步机制]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi/"/>
    <updated>2015-06-08T00:02:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi</id>
    <content type="html"><![CDATA[<blockquote>
  <ol>
    <li>及时响应用户</li>
    <li>实现多核调度</li>
  </ol>
</blockquote>

<!--more-->

<h3 id="nsoperation">NSOperation</h3>
<ol>
  <li>封装了大部分异步相关的逻辑，基础类，使用的时候要继承它创建我们自己的子类；</li>
  <li>系统实现的具体的类：NSInvocationOperation，NSBlockOperation；</li>
  <li>Dependency，Completion block，KVO，Priority，Cancel</li>
  <li>non-concurrent
    <ul>
      <li>重写main()</li>
      <li>autoreleasepool</li>
      <li>不需要自己维护状态</li>
    </ul>
  </li>
  <li>concurrent
    <ul>
      <li>实现start()</li>
      <li>实现异步操作</li>
      <li>自己维护isFinished，isExcuting，isCancelled（manual KVO）</li>
    </ul>
  </li>
  <li>判断是否cancel
    <ul>
      <li>main/start</li>
      <li>循环开始处</li>
      <li>逻辑区分点</li>
    </ul>
  </li>
</ol>

<h3 id="dispatch-queue">dispatch queue</h3>
<ol>
  <li>将业务逻辑写在block里
    <ul>
      <li>
        <p>定义：</p>

        <pre><code>  ^return type(params){expression}	
  typedef return type(^name)(params)
</code></pre>
      </li>
      <li>
        <p>声明：</p>

        <pre><code>  self.block = ^(params){expression};
</code></pre>
      </li>
      <li>
        <p>方法中定义的block在stack上，当调用copy时，会copy到heap上</p>
      </li>
    </ul>
  </li>
  <li>finalizer</li>
  <li>Serial(private dispatch queue)
    <ul>
      <li>block间顺序执行</li>
      <li>dispatch_queue_create()</li>
      <li>
        <p>需要自己维护reference count:</p>

        <pre><code>  dispatch_release()
</code></pre>
      </li>
    </ul>
  </li>
  <li>Concurrent(global dispatch queue)
    <ul>
      <li>block间并发执行</li>
      <li>dispatch_get_global_queue()</li>
      <li>normal, low, high</li>
      <li>系统维护reference count</li>
    </ul>
  </li>
  <li>main dispatch queue
    <ul>
      <li>在主线程run loop执行</li>
      <li>更新UI/主线程作为同步</li>
    </ul>
  </li>
  <li>dispatch queue维护自己的autoreleasepool</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImageView和UIButton拉伸效果的实现]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian/"/>
    <updated>2015-05-27T11:49:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>UIImageView中Image拉伸效果的实现：</p>

<pre><code>UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;
</code></pre>

<!--more-->

<p>但是虽然UIButton和UIImageView都是继承于UIView，但是二者实现方式不同，UIImageView没有subView，它 的content就是image，UIBotton不同，the way it works is a private implementation detail。</p>

<p>因此UIButton实现背景拉伸，即图片两端不拉伸中间拉伸的办法有如下两种：</p>

<p>第一种方法很简单而且使用性更广。做法就是直接拉伸想要setBackgroundImage的image，代码如下：</p>

<pre><code>UIImage*image =[UIImage imageNamed:@"image.png"];

image = [image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];

image =[image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];
</code></pre>

<p>设置了左端帽之后，rightCapWidth = image.size.width - (image.leftCapWidth + 1); 也就是说图片中间的一像素用来拉伸。垂直方向同上。</p>

<p>设置之后无论把image放到什么控件中都可以自动拉伸了。</p>

<p>第二种方法是在UIButton中加入一个UIImageView，拉伸imageView，然后将button的背景设为clearColor等等。把imageView放入button中，并且sendToBack，得到效果。</p>

<p>代码如下：</p>

<pre><code>//刚才imageView拉伸的代码

UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;

//把imageView放入button中，并设置为back


[temp_button addSubview:backgroundImageView];
[temp_button sendSubviewToBack:backgroundImageView];
[temp_button setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p>button不能设置背景图片，这样就可以实现拉伸的图片作为背景并且背景上可以放置title。</p>
]]></content>
  </entry>
  
</feed>
