<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[402]]></title>
  <link href="http://blog.oneboxapp.com/atom.xml" rel="self"/>
  <link href="http://blog.oneboxapp.com/"/>
  <updated>2015-06-27T12:02:48+08:00</updated>
  <id>http://blog.oneboxapp.com/</id>
  <author>
    <name><![CDATA[Kimimaro]]></name>
    <email><![CDATA[kimirius@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[有符号定点数的表示方法]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/you-fu-hao-ding-dian-shu-de-biao-shi-fang-fa/"/>
    <updated>2015-06-27T11:54:10+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/you-fu-hao-ding-dian-shu-de-biao-shi-fang-fa</id>
    <content type="html"><![CDATA[<p> 有符号定点数用首位0表示正，1表示负，正数与负数的补码求法不同。</p>

<ul>
  <li>正数的原码，反码，补码相同（这条要首先牢记，之后才能记住负数反码，补码的求法）；</li>
  <li>负数的反码是除原码符号为外按位求反，负数的补码是对原码按位求反之后加1。
反码的作用不大，主要要记住反码的作用。</li>
</ul>

<p><strong>补码的设计目的是:</strong></p>

<ol>
  <li>使符号位能与有效值部分一起参加运算,从而简化运算规则；</li>
  <li>使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计 。
移码主要应用于浮点数的运算中，有关移码的介绍在网上查了一下居然没有找到，都是些数据结构基础中就介绍的，以后有空要写个总结记录一下。
作为一个小白，我觉得更重要的不是记住上面的运算方法，这些都异常简单，重要的是记住某些特殊值或者规律，这些能帮我们计算的更快，反应的更迅速，感兴趣的朋友可以在下面写出你掌握的规律。</li>
</ol>

<p>比如说：
数值0原码两个，反码两个，补码只有一个；
由上述特点直接衍生出的是补码可以多表示一个数字，若字长为8位，补码中就多了一个-128，补码可以表示256个数；</p>

<hr />
<p>我的理解绝大部分的也运算都应该采用补码形式，具体的原因就很多了；
进行补码运算时，应注意所得结果不应超过补码所能表示数的范围；
在以二进制补码表示负数的机器上，~（按位运算符）10的结果为十进制数-11；
等等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移位运算符]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/yi-wei-yun-suan-fu/"/>
    <updated>2015-06-27T11:50:43+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/yi-wei-yun-suan-fu</id>
    <content type="html"><![CDATA[<blockquote>
  <p>移位运算先转化成2进制，再根据运算符指定的位数作以为运算。
左移运算符（«）：逻辑/算数移位。在不考虑溢出的情况下，相当于乘2，移位时移出的位数全部丢弃，右侧补入的数全部是0；左移时要注意有符号数的溢出情况。
右移运算符（»）：算术运算，对于无符号数以及有符号正数相当于除2，移位时溢出的位数全部丢弃，补入的数分为两种情况：如果是无符号数，左侧全部补0；如果是有符号数与符号位和编译器有关，一般情况下补符号位的副本。</p>
</blockquote>

<hr />
<p>移位计数的取值问题：</p>

<ol>
  <li>
    <p>网上查到的结果是如果移动的位数超过类型的长度时，会对移位计数取余，举个小例子：</p>

    <p>int i = 1, j = 0x80000000; //设int为32位
   i = i « 33;     // 33 % 32 = 1 左移1位,i变成2
   j = j « 33;     // 33 % 32 = 1 左移1位,j变成0,最高位被丢弃</p>
  </li>
  <li>
    <p>《C Traps and Pitfalls》这本书上说的是：移位计数必须大于等于0，而严格小于n（如上例的32位），即：i « 32 和 i«-1这种写法都是非法的，我猜是这本书出版的时间比较早，但是我还是更喜欢这样的做法。</p>
  </li>
</ol>

<p>除法运算代替以为运算，将导致程序运行速度大大减慢。换句话说：使用移位预算符将大大提高程序的执行效率。对于这一点我将在自己以后的应用中继续总结。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImageView和UIButton拉伸效果的实现]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian/"/>
    <updated>2015-06-27T11:49:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>UIImageView中Image拉伸效果的实现：</p>

<pre><code>UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;
</code></pre>

<p>但是虽然UIButton和UIImageView都是继承于UIView，但是二者实现方式不同，UIImageView没有subView，它 的content就是image，UIBotton不同，the way it works is a private implementation detail。</p>

<p>因此UIButton实现背景拉伸，即图片两端不拉伸中间拉伸的办法有如下两种：</p>

<p>第一种方法很简单而且使用性更广。做法就是直接拉伸想要setBackgroundImage的image，代码如下：</p>

<pre><code>UIImage*image =[UIImage imageNamed:@"image.png"];

image = [image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];

image =[image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];
</code></pre>

<p>设置了左端帽之后，rightCapWidth = image.size.width - (image.leftCapWidth + 1); 也就是说图片中间的一像素用来拉伸。垂直方向同上。</p>

<p>设置之后无论把image放到什么控件中都可以自动拉伸了。</p>

<p>第二种方法是在UIButton中加入一个UIImageView，拉伸imageView，然后将button的背景设为clearColor等等。把imageView放入button中，并且sendToBack，得到效果。</p>

<p>代码如下：</p>

<pre><code>//刚才imageView拉伸的代码

UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;

//把imageView放入button中，并设置为back


[temp_button addSubview:backgroundImageView];
[temp_button sendSubviewToBack:backgroundImageView];
[temp_button setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p>button不能设置背景图片，这样就可以实现拉伸的图片作为背景并且背景上可以放置title。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于git分支的使用]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/guan-yu-gitfen-zhi-de-shi-yong/"/>
    <updated>2015-06-27T11:48:12+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/guan-yu-gitfen-zhi-de-shi-yong</id>
    <content type="html"><![CDATA[<p>学习记录，不正确的地方望指正！</p>

<p>git branch 显示的是本地分支</p>

<p>git pull origin aRemoteBranch</p>

<p>git push origin aRemoteBranch</p>

<p>git commit 是提交到当前的本地分支</p>

<p>git remote显示远程服务器</p>

<p>git remote show aRemote显示指定的远程服务器（origin）上的远程分支</p>

<p>git checkout –track -b aLocalBranch aRemote/aRemoteBranch 创建一个新本地分支追踪远程分支（也可以直接 git checkout aRemoteBranch）</p>

<p>远程分支不可见，只能通过新建本地分支来追踪远程分支，本地分支和远程分支是两个不同的东西，也可以不同名。</p>

<p>checkout的时候会先检查本地分支，如果有则checkout到这个本地分支（不论它track哪个远程分支），如果没有则查看远程分支，如果有同名远程分支则新建一个本地同名分支并追踪（track）远程分支</p>

<p>git branch -d aLocalBranch  删除本地分支</p>

<p>git push ARemote :aRemoteBranch 删除远程分支</p>

<p>-d -&gt; -D 强制删除</p>

<p>vim .git/config</p>

<p>可以查看当前的remote和已经track了remote分支的本地分支</p>

<p>可以建多个本地分支track同一个远程分支，删除本地分支对远程分支没有影响。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APNs实现小记]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/apnsshi-xian-xiao-ji/"/>
    <updated>2015-06-27T11:07:51+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/apnsshi-xian-xiao-ji</id>
    <content type="html"><![CDATA[<blockquote>
  <p>转自己以前写的博客，很早时候的学习笔记了，不过下面几个连接貌似都失效了。。。囧</p>
</blockquote>

<p>推荐如下链接，前两个介绍APNs的设置流程，已经很详尽，虽然很详尽但是个人感觉有些晦涩难懂，把简单的流程搞的复杂。我下面的内容是我设置APNs的过：</p>

<p>[iPhone消息推送服务实现 - vber的专栏 - 博客频道 - CSDN.NET]</p>

<p>[apple push notification service apple与Python结合推送 - iOS开发讨论区 - Tiny4Cocoa]</p>

<table>
  <tbody>
    <tr>
      <td>[编写push notification之获取device token</td>
      <td>Marshal’s Blog]</td>
    </tr>
  </tbody>
</table>

<p><a href="http://slj.me/2010/02/iphone-push-notification/">偷窥iPhone Push Notification的幕后 - SLJ.me - 申力军</a></p>

<table>
  <tbody>
    <tr>
      <td>[iPhone的Push(推送通知)功能原理浅析 - iPhone/iPad 进阶讨论区 - 悦Phone论坛 iPhone</td>
      <td>iPad开发者、苹果开发者]</td>
    </tr>
  </tbody>
</table>

<p> 第一次接触APNs，鼓捣了一下午终于有了点眉目。</p>

<p> 链接1,2的流程介绍都是从最基础的入门级介绍，其实在你开发一款iOS app时，你需要做的是申请开发者帐号，设置Apple ID，生成provisioning file导入到Xcode，而APNs只是在设置Apple ID的时候多选择了一个选项，即Apple ID 的configure页面的 Enable for Apple Push Notification service选项，勾选它，然后根据你的需要生成dev或者release版本的SSL证书（证书生成的过程apple已经给了详尽的提示）。这里要注意的是，勾选了enable for apns之后，其实你的provisioning file已经改变，所以要重新下载新的导入Xcode。</p>

<hr />
<p>此时，你的app已经支持apns了。</p>

<p> 之后需要做的是两个方面：</p>

<ol>
  <li>
    <p>客户端 在appDelegate中编写代码，为了阅读方便就把上面链接中的代码重新贴一次：</p>

    <pre><code> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {  
   [[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |    UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];  
 }  
 - (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err {  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"Error in registration. Error: %@", err] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 }  
 - (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
   NSLog(@"devToken=%@",deviceToken);  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"devToken=%@",deviceToken] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 } 
</code></pre>
  </li>
</ol>

<p> 其实就是在appDidFinishLaunch的时候注册（register）apns，然后通过didRegisterForRemoteNotificationsWithDeviceToken得到DeviceToken。</p>

<p>接受服务器消息并改变客户端本地状态（如在app图表显示带数字的小红圈）的代码如下：</p>

<pre><code>	－(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
	
	    for (id key in userInfo) {
	        NSLog(@"key: %@, value: %@", key, [userInfo objectForKey:key]);
	    }    
	}
</code></pre>

<p> 到此为止，当你在真机上运行你的app时就会出现：是否允许app显示push notification的提示框。</p>

<ol>
  <li>服务器端 服务器端可以用PHP，Python等实现，网上也有一些现成的库如开源库APNSWrapper。现在你会发现我理解的思路跟链接1,2的介绍流程稍有不同，同时你会发现我还没有使用Enable for Apple Push Notification service时生成的证书文件，现在回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，关于这个文件要多说几句：</li>
</ol>

<blockquote>
  <p>这个文件的作用是让apple的APNs服务器确认服务器端具有push notification的权限。将这个证书作一定的处理（＊至于是什么处理为了不影响文章的连贯性会在下面介绍），生成一个ck.pem文件（这个名字可以自定义）。</p>
</blockquote>

<p> 然后就要涉及到APNs的工作机制，我的总结如下：当一个device（苹果设备）启用apns功能（就是通知功能）的时候会和apple的APNs服务器建立TLS连接，APNs服务器根据device的UDID和加密密钥新建一个DeviceToken（它的作用是让服务器端指定device，唯一）返回给device，然后device会把device token给你的app客户端，这时会调用刚才写的didRegisterForRemoteNotificationsWithDeviceToken方法，你可以在这个方法中将device token返回给服务器端。此后，如果服务器端push了一个notification给客户端，需要将这个device token和之前处理的ck.pem文件同时发送给APNs服务器，APNs服务器会验证你的ck.pem文件然后根据device token指定的设备推送消息给客户端）。当客户端接受到push的通知时调用didReceiveRemoteNotification方法，你可以在这个方法中放入你需要的操作。</p>

<blockquote>
  <p>现在再回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，对它的处理链接1,2都有介绍，就是：</p>
</blockquote>

<ol>
  <li>
    <p>选择“我的证书”, 选定推送服务证书(Apple Development Push Services*),导出到桌面,保存为Certificates.p12。</p>
  </li>
  <li>
    <p>在终端中运行如下命令:</p>

 	openssl pkcs12 -clcerts -nokeys -out cert.pem -in Certificates.p12<br />
 	openssl pkcs12 -nocerts -out key.pem -in Certificates.p12<br />
 	openssl rsa -in key.pem -out key.unencrypted.pem<br />
    <pre><code> 	cat cert.pem key.unencrypted.pem &gt; ck.pem  

 ck.pem文件则是PHP推送消息时所使用的证书文件。
</code></pre>
  </li>
</ol>

<p> 你剩下的任务就是编写服务器端的代码，push notification，这部分只要记住发送device token和证书文件就可以了。</p>

<p>（以上就是我理解学习APNs的过程，许多理解都不深入，所以描述也不准确，包涵～）</p>

<h2 id="section">更新：</h2>

<p><strong>开发中遇到的问题汇总</strong>：</p>

<ol>
  <li>
    <p>正常的iPhone刷系统之后，是没有设备证书和密钥的。这就是为什么iPhone会需要连接到 iTunes上进行激活——激活过程中，Apple会分配给每台iPhone独一无二的设备证书(device certificate)和密钥(key)。(如果没有意识到这个会一直收到 “未找到应用程序的”aps-environment” 的权利字符串)</p>
  </li>
  <li>
    <p>如果生成appleID的时候没有enable aps，那么enable之后一定要删掉原来的dev和rc证书重新生成，这样才能保证开启新功能，否则仅仅是刷新这张证书仍然会没有aps，提示（ “未找到应用程序的”aps-environment” 的权利字符串）</p>
  </li>
  <li>
    <p>APNs证书如果是系统证书那么最好拷贝到登陆证书中，这样可以直接导出成p12</p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SIGABRT错误的调试办法]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150627/sigabrtcuo-wu-de-diao-shi-ban-fa/"/>
    <updated>2015-06-27T10:50:39+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150627/sigabrtcuo-wu-de-diao-shi-ban-fa</id>
    <content type="html"><![CDATA[<p>iOS经常会遇到一个头疼的error就是在main函数上显示“ Thread 1: signal SIGABRT ”这个错误，终于在stackoverflow上找到了调试的办法：</p>

<p><a href="http://stackoverflow.com/questions/9782621/i-have-an-error-in-main-m-thread-1-signal-sigabrt-how-can-i-fix-this">原文链接</a></p>

<p>重点就是 <strong>Set an exception breakpoint.</strong></p>

<p>之前我们遇到的在main函数上的那个崩溃信息，如果想要调试就加入一个 an exception breakpoint ，它会在exception 被 cathc 的时候停下来，这样就可以追踪到造成 exception 的代码了。</p>

<p>加入一个exception breakpoint的方法就是：在navigator的断点页面，点击左下角的加号就能看到 exception breakpoint；</p>

<p>加入的时候可以设置，默认是 all，也可以选择针对 oc 还是 c 的断点。</p>

<blockquote>
  <p>原文：</p>

  <p>When you get SIGABRT on that line of main, it means that your program is raising an exception. The stack trace shows where the exception is being caught, &gt;not where it’s being raised. Usually this is not helpful. To debug the problem, you can do two things:</p>

  <ol>
    <li>
      <p>Click the “Continue Program Execution” button in the debugger control bar, or choose Program &gt; Debug &gt; Continue from the menu bar. This will let the program continue the exception-raising process. It will print a message to the debugger console that will help you understand what’s wrong. (You may have &gt;to continue execution a couple of times before it actually prints messages.) Read the messages carefully! They usually continue helpful information.</p>
    </li>
    <li>
      <p>Set an exception breakpoint. This will make Xcode stop your program at the point where the exception is being raised, so you can see the code and the stack trace that is causing the problem.</p>
    </li>
  </ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch与Wax对比分析]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi/"/>
    <updated>2015-06-18T19:19:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchdui-bi</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="https://github.com/bang590/JSPatch">JSPatch</a>与<a href="https://github.com/probablycorey/wax">Wax</a>作为iOS平台上两大热更新框架使用不同的语言、基于相同的原理（ObjC动态绑定）一直备受iOS开发者的青睐，Wax出现较早且已经不再维护，但是也有了各种各样的分支版本；JSPatch作为后起之秀得益于iOS7苹果开放了JavascriptCore.framework的API，相比以前的Wax框架有了很多更新，下面就根据以往的开发经验简单比较一下二者的优势劣势，如果想对两个框架有更多的了解，请移步上文的官方网站和相关文档。</p>
</blockquote>

<ol>
  <li>JSPatch相比于Wax的优势</li>
  <li>JSPatch相比于Wax的劣势</li>
</ol>

<hr />

<h1 id="jspatchwax">JSPatch相比于Wax的优势</h1>

<h2 id="section">内存管理</h2>
<ul>
  <li>JSPatch中JSValue负责维护被引用OC对象的生命周期，如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</li>
  <li>Wax在引用OC对象需要打上waxRetain标记，然后跑一个定时的GC查看这个对象的retainCount，当发现一个不再需要引用的对象retainCount大于1并且waxRetain为YES时（实际上的判断逻辑要复杂一些），就释放这个对象。依赖于retainCount，苹果官方是不推荐的，也不安全。</li>
</ul>

<h2 id="section-1">类型转换</h2>
<ul>
  <li>
    <p>JSPatch使用的是系统提供的类型转换，JSValue类内部可以看到完整的JS类型与OC的映射关系，同时支持NSArray和NSDictionary等类型的嵌套解析;</p>

    <pre><code>  @textblock
     Objective-C type  |   JavaScript type
   --------------------+---------------------
           nil         |     undefined
          NSNull       |        null
         NSString      |       string
         NSNumber      |   number, boolean
       NSDictionary    |   Object object
         NSArray       |    Array object
          NSDate       |     Date object
         NSBlock (1)   |   Function object (1)
            id (2)     |   Wrapper object (2)
          Class (3)    | Constructor object (3)
  @/textblock
</code></pre>
  </li>
  <li>
    <p>Lua中调用OC对象需要使用toobjc方法，否则会Crash，还有一个问题是NSDictionary、NSArray使用时是被copy的，也就是说你无法直接更改OC内存中的那个对象。</p>
  </li>
</ul>

<h2 id="section-2">多线程</h2>
<ul>
  <li>由于JSCore的支持，JS脚本实现的方法在多线程中调用没有任何问题，同时JSPatch也针对GCD提供了封装；</li>
  <li>Lua语言本身是不支持多线程的，多个线程同时调用Lua就等于同时操作同一张Lua元表，可能出问题；同时Wax调用异步的话只能依赖performSelectorInBackground:了。</li>
</ul>

<h2 id="block">Block</h2>
<ul>
  <li>JSPatch：天然支持，JS的Function类型会对应转换成NSBlock执行；</li>
  <li>个人认为Wax最受诟病的一点，无法支持Block使得方法替换和扩展都受到很大限制。</li>
</ul>

<h2 id="section-3">类型扩展</h2>
<ul>
  <li>JSPatch提供了CGRect、CGPoint、NSRange支持</li>
  <li>Lua调用OC对象时需要toobjc，NSDictionary、NSArray只支持copy，不支持retain</li>
</ul>

<h2 id="section-4">参数传递</h2>
<blockquote>
  <p>为了替换方法实现，将方法传递到脚本语言的实现过程中必须知道当前方法的参数类型列表，传统的方法是用va_list得到，但是arm64上va_list的实现更改无法根据内存位置取出参数，对于这个坑也是困了好久才解决。但是个人认为bang牛给了一个更好的解法。</p>
</blockquote>

<ul>
  <li>JSPatch为了解决arm64上va_list拿不到参数的问题，使用forwardInvocation方式，支持各种类型参数枚举；</li>
  <li>Wax框架维护期间还没有出现arm64所以也就一直平静的使用va_list，当然现在升级的话也可以使用JSPatch的这种方式；</li>
</ul>

<h1 id="jspatchwax-1">JSPatch相比于Wax的劣势</h1>

<h2 id="section-5">消息转发</h2>
<ul>
  <li>JS语言不支持消息转发，对于一个对象如果不响应方法就直接崩溃了，所以bang牛用正则替换了方法调用，然后通过桥接方法 __c() 来实现；</li>
  <li>Lua解析后的方法、变量都放到元表中，支持消息转发，算是一个非常好的特性。</li>
</ul>

<h2 id="ios6">iOS6支持</h2>
<ul>
  <li>JSPatch基于JSCore，仅支持iOS7+</li>
  <li>Wax理论上支持所有iOS版本。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch初探]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan/"/>
    <updated>2015-06-18T11:56:50+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/jspatchchu-tan</id>
    <content type="html"><![CDATA[<hr />
<ol>
  <li>JSPatch是什么？</li>
  <li>Objective-C动态绑定机制</li>
  <li>JSPatch原理</li>
  <li>JSPatch实用举例</li>
  <li>与现有方案（Wax）的对比</li>
</ol>

<hr />

<blockquote>
  <p><a href="http://blog.cnbang.net/tech/2808/">JSPatch实现原理详解</a></p>
</blockquote>

<h2 id="jspatch">一、JSPatch介绍</h2>
<blockquote>
  <p>最直观的介绍莫过于官方文档</p>
</blockquote>

<ul>
  <li><a href="https://github.com/bang590/JSPatch">bang590/JSPatch</a></li>
  <li>利用OC Runtime桥接Objective-C和JavaScript</li>
  <li>用处：
    <ul>
      <li>添加模块</li>
      <li>修复线上Bug</li>
    </ul>
  </li>
</ul>

<h2 id="oc">二、OC动态绑定机制</h2>
<blockquote>
  <p>一切iOS平台上实现动态BugFix和新增模块的技术都基于ObjC的动态绑定、动态加载、消息转发</p>
</blockquote>

<ul>
  <li>所谓动态绑定就是利用OC Runtime可以做如下几件事情：
    <ul>
      <li>给已有类增加方法</li>
      <li>替换现有类的方法指针，指向新的方法实现</li>
      <li>动态创建一个类</li>
    </ul>
  </li>
  <li>
    <p>【类对象】动态绑定机制源于OC的动态类实现</p>

    <pre><code>      #import &lt;objc/runtime.h&gt;
</code></pre>

    <ul>
      <li>除基本类型外所有OC类都继承于NSObject类</li>
      <li>NSObject对象有一个指向该实例所属类的isa指针</li>
      <li>OC中的类也是一个对象的概念，因此我们可以动态的创建一个类对象</li>
      <li>objc_allocateClassPair</li>
      <li>class_addMethod</li>
      <li>objc_registerClassPair</li>
    </ul>
  </li>
  <li>【消息】方法替换和新增源于消息转发机制
    <ul>
      <li>OC中方法调用起始是一个对象响应消息的过程</li>
      <li>可响应消息列表存在于对象isa指针所指向的类对象上</li>
      <li>objc_msgSend</li>
      <li>forwardInvocation:</li>
    </ul>
  </li>
</ul>

<h2 id="jspatch-1">三、JSPatch原理</h2>
<blockquote>
  <p>通过forwardInvocation方法，将</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步机制]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150618/yi-bu-ji-zhi/"/>
    <updated>2015-06-18T00:02:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150618/yi-bu-ji-zhi</id>
    <content type="html"><![CDATA[<blockquote>
  <ol>
    <li>及时响应用户</li>
    <li>实现多核调度</li>
  </ol>
</blockquote>

<h3 id="nsoperation">NSOperation</h3>
<ol>
  <li>封装了大部分异步相关的逻辑，基础类，使用的时候要继承它创建我们自己的子类；</li>
  <li>系统实现的具体的类：NSInvocationOperation，NSBlockOperation；</li>
  <li>Dependency，Completion block，KVO，Priority，Cancel</li>
  <li>non-concurrent
    <ul>
      <li>重写main()</li>
      <li>autoreleasepool</li>
      <li>不需要自己维护状态</li>
    </ul>
  </li>
  <li>concurrent
    <ul>
      <li>实现start()</li>
      <li>实现异步操作</li>
      <li>自己维护isFinished，isExcuting，isCancelled（manual KVO）</li>
    </ul>
  </li>
  <li>判断是否cancel
    <ul>
      <li>main/start</li>
      <li>循环开始处</li>
      <li>逻辑区分点</li>
    </ul>
  </li>
</ol>

<h3 id="dispatch-queue">dispatch queue</h3>
<ol>
  <li>将业务逻辑写在block里
    <ul>
      <li>
        <p>定义：</p>

        <pre><code>  ^return type(params){expression}	
  typedef return type(^name)(params)
</code></pre>
      </li>
      <li>
        <p>声明：</p>

        <pre><code>  self.block = ^(params){expression};
</code></pre>
      </li>
      <li>
        <p>方法中定义的block在stack上，当调用copy时，会copy到heap上</p>
      </li>
    </ul>
  </li>
  <li>finalizer</li>
  <li>Serial(private dispatch queue)
    <ul>
      <li>block间顺序执行</li>
      <li>dispatch_queue_create()</li>
      <li>
        <p>需要自己维护reference count:</p>

        <pre><code>  dispatch_release()
</code></pre>
      </li>
    </ul>
  </li>
  <li>Concurrent(global dispatch queue)
    <ul>
      <li>block间并发执行</li>
      <li>dispatch_get_global_queue()</li>
      <li>normal, low, high</li>
      <li>系统维护reference count</li>
    </ul>
  </li>
  <li>main dispatch queue
    <ul>
      <li>在主线程run loop执行</li>
      <li>更新UI/主线程作为同步</li>
    </ul>
  </li>
  <li>dispatch queue维护自己的autoreleasepool</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150617/first-post/"/>
    <updated>2015-06-17T23:37:54+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150617/first-post</id>
    <content type="html"><![CDATA[<h3 id="first-post">First Post</h3>
]]></content>
  </entry>
  
</feed>
