<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ios | 402]]></title>
  <link href="http://blog.oneboxapp.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.oneboxapp.com/"/>
  <updated>2015-09-09T15:59:12+08:00</updated>
  <id>http://blog.oneboxapp.com/</id>
  <author>
    <name><![CDATA[Kimimaro]]></name>
    <email><![CDATA[kimirius@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Blog List]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150831/ios-blog-list/"/>
    <updated>2015-08-31T17:35:48+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150831/ios-blog-list</id>
    <content type="html"><![CDATA[<blockquote>
  <p>还没来得及整理，各种途径搜集到的记录这里以后看。ps. 还是怀念greader时代啊。</p>
</blockquote>

<h3 id="ios">iOS</h3>
<ol>
  <li><a href="https://www.objc.io/">objc.io</a></li>
</ol>

<h3 id="section">图</h3>
<p><img src="http://7xl7vj.com1.z0.glb.clouddn.com/blog_list.png" alt="" /></p>

<h3 id="github">github</h3>
<ol>
  <li><a href="https://github.com/longv2go/iOSBlogCN">longv2go/iOSBlogCN</a></li>
</ol>

<h3 id="swift">Swift</h3>
<ol>
  <li><a href="http://swifter.tips/condition-compile/">Swifter - @ONECAT</a></li>
  <li><a href="http://natashatherobot.com/">Natasha The Robot</a></li>
  <li><a href="http://nshipster.cn/swift-objc-runtime/">Swift &amp; the Objective-C Runtime - NSHipster</a></li>
  <li><a href="https://developer.apple.com/swift/blog/">Swift Blog - Apple Developer</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wkwebview]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150826/wkwebview/"/>
    <updated>2015-08-26T15:53:26+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150826/wkwebview</id>
    <content type="html"><![CDATA[<blockquote>
  <p><a href="http://nshipster.cn/wkwebkit/">WKWebView - NSHipster</a></p>

  <table>
    <tbody>
      <tr>
        <td>[WKWebView的新特性与使用</td>
        <td>发光的我](http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html)</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="wkwebkit-framework">WKWebKit Framework</h1>

<h1 id="nirtro-javascript">Nirtro JavaScript</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步机制]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi/"/>
    <updated>2015-06-08T00:02:06+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150608/yi-bu-ji-zhi</id>
    <content type="html"><![CDATA[<blockquote>
  <ol>
    <li>及时响应用户</li>
    <li>实现多核调度</li>
  </ol>
</blockquote>

<!--more-->

<h3 id="nsoperation">NSOperation</h3>
<ol>
  <li>封装了大部分异步相关的逻辑，基础类，使用的时候要继承它创建我们自己的子类；</li>
  <li>系统实现的具体的类：NSInvocationOperation，NSBlockOperation；</li>
  <li>Dependency，Completion block，KVO，Priority，Cancel</li>
  <li>non-concurrent
    <ul>
      <li>重写main()</li>
      <li>autoreleasepool</li>
      <li>不需要自己维护状态</li>
    </ul>
  </li>
  <li>concurrent
    <ul>
      <li>实现start()</li>
      <li>实现异步操作</li>
      <li>自己维护isFinished，isExcuting，isCancelled（manual KVO）</li>
    </ul>
  </li>
  <li>判断是否cancel
    <ul>
      <li>main/start</li>
      <li>循环开始处</li>
      <li>逻辑区分点</li>
    </ul>
  </li>
</ol>

<h3 id="dispatch-queue">dispatch queue</h3>
<ol>
  <li>将业务逻辑写在block里
    <ul>
      <li>
        <p>定义：</p>

        <pre><code>  ^return type(params){expression}	
  typedef return type(^name)(params)
</code></pre>
      </li>
      <li>
        <p>声明：</p>

        <pre><code>  self.block = ^(params){expression};
</code></pre>
      </li>
      <li>
        <p>方法中定义的block在stack上，当调用copy时，会copy到heap上</p>
      </li>
    </ul>
  </li>
  <li>finalizer</li>
  <li>Serial(private dispatch queue)
    <ul>
      <li>block间顺序执行</li>
      <li>dispatch_queue_create()</li>
      <li>
        <p>需要自己维护reference count:</p>

        <pre><code>  dispatch_release()
</code></pre>
      </li>
    </ul>
  </li>
  <li>Concurrent(global dispatch queue)
    <ul>
      <li>block间并发执行</li>
      <li>dispatch_get_global_queue()</li>
      <li>normal, low, high</li>
      <li>系统维护reference count</li>
    </ul>
  </li>
  <li>main dispatch queue
    <ul>
      <li>在主线程run loop执行</li>
      <li>更新UI/主线程作为同步</li>
    </ul>
  </li>
  <li>dispatch queue维护自己的autoreleasepool</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImageView和UIButton拉伸效果的实现]]></title>
    <link href="http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian/"/>
    <updated>2015-05-27T11:49:22+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20150527/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>UIImageView中Image拉伸效果的实现：</p>

<pre><code>UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;
</code></pre>

<!--more-->

<p>但是虽然UIButton和UIImageView都是继承于UIView，但是二者实现方式不同，UIImageView没有subView，它 的content就是image，UIBotton不同，the way it works is a private implementation detail。</p>

<p>因此UIButton实现背景拉伸，即图片两端不拉伸中间拉伸的办法有如下两种：</p>

<p>第一种方法很简单而且使用性更广。做法就是直接拉伸想要setBackgroundImage的image，代码如下：</p>

<pre><code>UIImage*image =[UIImage imageNamed:@"image.png"];

image = [image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];

image =[image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];
</code></pre>

<p>设置了左端帽之后，rightCapWidth = image.size.width - (image.leftCapWidth + 1); 也就是说图片中间的一像素用来拉伸。垂直方向同上。</p>

<p>设置之后无论把image放到什么控件中都可以自动拉伸了。</p>

<p>第二种方法是在UIButton中加入一个UIImageView，拉伸imageView，然后将button的背景设为clearColor等等。把imageView放入button中，并且sendToBack，得到效果。</p>

<p>代码如下：</p>

<pre><code>//刚才imageView拉伸的代码

UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;

//把imageView放入button中，并设置为back


[temp_button addSubview:backgroundImageView];
[temp_button sendSubviewToBack:backgroundImageView];
[temp_button setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p>button不能设置背景图片，这样就可以实现拉伸的图片作为背景并且背景上可以放置title。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURLConnection的同步与异步]]></title>
    <link href="http://blog.oneboxapp.com/blog/20140627/nsurlconnectionde-tong-bu-yu-yi-bu/"/>
    <updated>2014-06-27T12:15:00+08:00</updated>
    <id>http://blog.oneboxapp.com/blog/20140627/nsurlconnectionde-tong-bu-yu-yi-bu</id>
    <content type="html"><![CDATA[<p>从这篇文章中收益良多：http://www.cocoabyss.com/foundation/nsurlconnection-synchronous-asynchronous/</p>

<p>写下体会：（时间所限，比较杂乱，见谅！）</p>

<!--more-->
<hr />
<p>NSURLConnection的同步发送就不用说了，很简单，上面链接也说了，</p>

<p>异步在iOS5之前都是作为一个非正式的协议出现的，默认initWithRequestxxx方法发送的就是异步请求，然后通过delegate中的方法可以操作，之前我一直错误在发送异步请求的时候也开一个新的线程，看了文章之后才想明白这真的是没有必要，在其他线程跑conn的原因就是为了避免阻塞主UI线程，而现在cocoa使用了delegate帮助你避免了这个问题，所以根本不需要再开一个新的线程去请求，直接请求然后在delegate中handleData就可以了。</p>

<p>而回到对同步conn的使用，同步conn使用我认为是一定要在新线程中，这样避免了阻塞主线程的缺点（如文中所说），但是相比与aSync conn，sync还有其他缺点，如不能在请求同时操作数据，不能cancel等等，所以还是aSync要好用。</p>

<hr />

<p>iOS4之前如果想在新的线程使用异步发送的conn，最好的方法应该就是文中教的trick，而</p>

<p>iOS5之后添加了 NSURLConnectionDataDelegate 把之前非正式协议的一部分拿了过来变成了正是协议（formal protocol），里面包括了数据处理等代理方法，还增加了在线程中发送异步请求的方法：</p>

<pre><code>+ (void)sendAsynchronousRequest:(NSURLRequest *)request

                          queue:(NSOperationQueue*) queue

              completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*)) handler NS_AVAILABLE(10_7, 5_0);
</code></pre>

<p>这样我认为就不需要像上文作者那样trick了吧？</p>

<p>***)
另外还加入了NSURLConnectionDownloadDelegate，主要作用就是讲数据直接存入文件中，缓存的时候估计有用吧？</p>
]]></content>
  </entry>
  
</feed>
