
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>402</title>
	<meta name="author" content="Kimimaro">

	
	<meta name="description" content="链表（LinkList）的设计与实现（初始化，创建，插入，删除，逆置） 只是为了自己学习留作记录，需要的朋友可以看看。 修改日志： version1.1:2011-3-26 1.在尾插法中增加p-&gt;next = NULL;2.将类似于p==NULL改为NULL==p(示范性改正，没有全改 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="402" type="application/atom+xml">
	
	<link rel="canonical" href="http://blog.oneboxapp.com/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
  <!-- Fuck GFW, use local image -->
	<!-- <img src="http://www.gravatar.com/avatar/c56d402092b54cba7b9c5c4927ea123d?s=160" alt="Profile Picture" style="width: 160px;" /> -->
  <img src="/images/avatar.jpg" alt="Profile Picture" style="width: 160px;" />
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:kimirius@gmail.com" title="Email">Email</a>
		
		
		
		
			<a class="twitter" href="http://twitter.com/kimirius" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/kimimaro" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T12:08:20+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/lian-biao-(linklist)de-she-ji-yu-shi-xian-(chu-shi-hua-,chuang-jian-,cha-ru-,shan-chu-,ni-zhi-)/" itemprop="url">链表（LinkList）的设计与实现（初始化，创建，插入，删除，逆置）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>只是为了自己学习留作记录，需要的朋友可以看看。</p>

<p>修改日志：</p>

<p>version1.1:2011-3-26 1.在尾插法中增加p-&gt;next = NULL;2.将类似于p==NULL改为NULL==p(示范性改正，没有全改);</p>

<pre><code>//////////////////////////////////////
//单链表的表示与实现                //
//Author:YuTianhang               //
//Date:2011.3.23                    //

//Version:1.0                        //
//////////////////////////////////////

#include "stdafx.h"

typedef int ElemType;

//定义单链表的结点类型

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

////////////////////////////////////////////////

//单链表的初始化

int InitList(LinkList &amp;L)
{
    L = (LinkList)malloc(sizeof(LNode));    //申请结点空间

    if(NULL == L) printf("申请结点空间失败！\n");    //判断是否有足够的内存空间

    L-&gt;next = NULL;

    return 1;
}

///////////////////////////////////////////////

//头插法创建带头结点的单链表

int CreatList_H(LinkList &amp;L)
{
    L = (LinkList)malloc(sizeof(LNode));    //申请头结点空间
    L-&gt;next = NULL;    //初始化一个空链表

    ElemType e;

    printf("Input:!\n");

    while(scanf("%d",&amp;e) != EOF)
    {
        LNode *p;
        p = (LNode *)malloc(sizeof(LNode));    //建立一个新结点
        p-&gt;data = e;

        p-&gt;next = L-&gt;next;    //头插法插入结点p
        L-&gt;next = p;
    }

    //int i = 5;

    //while(i &gt; 0)
    //{
    //    scanf("%d",&amp;e);
    //   
    //    LNode *p;
    //    p = (LNode *)malloc(sizeof(LNode));    //建立一个新结点
    //    p-&gt;data = e;

    //    p-&gt;next = L-&gt;next;    //头插法插入结点p
    //    L-&gt;next = p;

    //    i--;
    //}

    return 1;
}

////////////////////////////////////////////////////////

//尾插法创建带头结点的链表

int CreatList_T(LinkList &amp;L)
{
    L = (LinkList)malloc(sizeof(LNode));
    L-&gt;next = NULL;

    ElemType e;
    LNode *r;
    r = L;
    while(scanf("%d",&amp;e) != EOF)
    {
        LNode *p;
        p = (LNode *)malloc(sizeof(LNode));
        p-&gt;data = e;

        p-&gt;next = NULL;    //第一次没有付空值，导致输出的时候p的next指针无法确定

        r-&gt;next = p;    //尾插法插入结点p
        r = p;
    }

    return 1;
}

///////////////////////////////////////////////////////

//在单链表的第i个位置插入元素e

int ListInsert(LinkList &amp;L,int i,ElemType e)
{
    LNode *pre;        //pre为i位置的前驱结点
    pre = L;
    while(i &gt; 0)    //查找i位置的前驱结点
    {
        pre = pre-&gt;next;
        --i;
    }

    LNode *p;
    p = (LNode *)malloc(sizeof(LNode));
    p-&gt;data = e;

    p-&gt;next = pre-&gt;next;    //将p结点插入到第i个位置
    pre-&gt;next = p;

    return 1;
}

/////////////////////////////////////////////////////////////

//在单链表中删除第i个结点并用e返回其结点值

int ListDelete(LinkList &amp;L,int i,ElemType &amp;e)
{
    LNode *pre;
    pre = L;

    while(i &gt; 0)
    {
        pre = pre-&gt;next;
        --i;
    }

    LNode *p;
    p = pre-&gt;next;
    e = p-&gt;data;

    pre-&gt;next = p-&gt;next;    //删除第i个位置的结点p
    free(p);

    return 1;
}

/////////////////////////////////////////////////////

//输入单链表的各项

int OutputList(LinkList L)
{
    if(L == NULL) printf("Error!\n");
    LNode *p;
    p = L-&gt;next;

    printf("Kimimaro:\n");
    do
    {
        if(p != L-&gt;next) printf(",");

        printf("%d",p-&gt;data);
        p = p-&gt;next;
    }while(p != NULL);

    printf("\n");

    return 1;
}

//////////////////////////////////////////////////

//单链表的逆置

int InvertList(LinkList &amp;L)
{
    LNode *p,*q,*r;
    p = L-&gt;next-&gt;next;
    q = p-&gt;next;

    r = L-&gt;next;
    r-&gt;next = NULL;

    while(p-&gt;next != NULL)
    {
        p-&gt;next = r;    //头插法插入结点p
        r = p;
        p = q;
        q = p-&gt;next;
    }

    p-&gt;next = r;    //最后一个结点的处理
    L-&gt;next = p;

    //while(p != NULL)                            //错误代码，导致最后两个结点循环？
    //{
    //    p-&gt;next = L-&gt;next;    //头插法插入结点p
    //    L-&gt;next = p;
    //    p = q;
    //    q = p-&gt;next;
    //}

    //p-&gt;next = L-&gt;next;    //最后一个结点的处理
    //L-&gt;next = p;

    return 1;
}

int _tmain(int argc, _TCHAR* argv[])
{
    LinkList L;

    CreatList_H(L);

    OutputList(L);

    int i = 3;
    ElemType e = 22;
    ListInsert(L,i,e);

    OutputList(L);

    /*ListDelete(L,i,e);

    OutputList(L);*/

    InvertList(L);

    OutputList(L);

    char ch;
    ch = getchar();
    return 0;
}
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T12:07:27+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/er-fen-fa-cha-zhao-de-shi-xian-(di-gui-and-xun-huan-)/" itemprop="url">二分法查找的实现（递归&amp;循环）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<pre><code>	#include "stdafx.h"
	
	//////////////////////////////////////////
	//二分查找                            //
	//Author:Kimimaro                    //
	//Date:2010-3-28                    //
	/////////////////////////////////////////
	
	typedef int KeyType;    //定义关键字类型
	
	//typedef struct        //定义数据元素结构
	//{
	//    KeyType key;    //关键字域
	//}SElemType;
	
	//宏定义关键字比较操作
	
	#define EQ(a,b) ((a) == (b))
	#define LT(a,b) ((a) &lt;  (b))
	#define LQ(a,b) ((a) &lt;= (b))
	
	//定义表长
	
	#define MAX 5
	
	//----------------静态查找表的顺序存储结构-------------------
	
	typedef struct
	{
	    KeyType *elem;
	    int length;
	}SSTable;
	
	//创建指定长度的静态查找表
	
	int CreatSST(SSTable &amp;S,int n)
	{
	    S.length = n;
	    S.elem = (KeyType*)malloc(S.length*sizeof(KeyType));
	
	    int i = 1;
	
	    while(scanf("%d",&amp;(S.elem[i])) != EOF)
	    {
	        i++;
	    }
	   
	    return 0;
	}
	
	//递归二分查找
	
	int binarySearch(SSTable S,KeyType key,int low,int high)
	{
	    if(low &gt; high) return -1;
	
	    int mid = (low + high) / 2;
	
	    if(EQ(key, S.elem[mid])) return mid;
	    else if(LT(key, S.elem[mid])) binarySearch(S,key,low,mid - 1);
	    else binarySearch(S,key,mid + 1,high);
	}
	
	//循环二分查找
	
	//int binarySearch(SSTable S,KeyType key)
	//{
	//    int low = 1,high = S.length,mid;
	//
	//    while(low &lt;= high)
	//    {
	//        mid = (low + high) / 2;
	//
	//        if(EQ(key,mid)) return mid;
	//        else if(LT(key,mid)) high = mid - 1;
	//        else low = mid + 1;
	//    }
	//
	//    return -1;
	//}
	
	int _tmain(int argc, _TCHAR *argv[])
	{
	    SSTable S;
	    CreatSST(S,MAX);
	
	    for(int i = 1;i &lt;= S.length;i++)
	    {
	        printf("%d ",S.elem[i]);
	        if(i == S.length) printf("\n");
	    }
	
	    int key;
	    printf("Which number do you want to search?\n");
	    scanf("%d",&amp;key);
	
	    int location;
	//    location = binarySearch(S,key);        //循环二分查找
	    location = binarySearch(S,key,1,S.length);        //递归二分查找
	    char chs = getchar();
	    printf("The elem is S.elem[%d].\n",location);
	
	    char ch = getchar();
	   
	    return 0;
	}
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T12:05:57+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/javatong-ji-cheng-xu-yun-xing-shi-jian-(zhuan-)/" itemprop="url">Java统计程序运行时间（转）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>代码如下：
第一种是以毫秒为单位计算的。</p>

<pre><code>long startTime = System.currentTimeMillis();    //获取开始时间

doSomething();    //测试的代码段

long endTime = System.currentTimeMillis();    //获取结束时间

System.out.println("程序运行时间：" + (endTime - startTime) + "ms");    //输出程序运行时间
</code></pre>

<p>第二种是以纳秒为单位计算的。</p>

<pre><code>long startTime=System.nanoTime();   //获取开始时间  

doSomeThing(); //测试的代码段  

long endTime=System.nanoTime(); //获取结束时间  

System.out.println("程序运行时间： "+(endTime-startTime)+"ns"); 
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T11:54:10+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/you-fu-hao-ding-dian-shu-de-biao-shi-fang-fa/" itemprop="url">有符号定点数的表示方法</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p> 有符号定点数用首位0表示正，1表示负，正数与负数的补码求法不同。</p>

<ul>
  <li>正数的原码，反码，补码相同（这条要首先牢记，之后才能记住负数反码，补码的求法）；</li>
  <li>负数的反码是除原码符号为外按位求反，负数的补码是对原码按位求反之后加1。
反码的作用不大，主要要记住反码的作用。</li>
</ul>

<p><strong>补码的设计目的是:</strong></p>

<ol>
  <li>使符号位能与有效值部分一起参加运算,从而简化运算规则；</li>
  <li>使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计 。
移码主要应用于浮点数的运算中，有关移码的介绍在网上查了一下居然没有找到，都是些数据结构基础中就介绍的，以后有空要写个总结记录一下。
作为一个小白，我觉得更重要的不是记住上面的运算方法，这些都异常简单，重要的是记住某些特殊值或者规律，这些能帮我们计算的更快，反应的更迅速，感兴趣的朋友可以在下面写出你掌握的规律。</li>
</ol>

<p>比如说：
数值0原码两个，反码两个，补码只有一个；
由上述特点直接衍生出的是补码可以多表示一个数字，若字长为8位，补码中就多了一个-128，补码可以表示256个数；</p>

<hr />
<p>我的理解绝大部分的也运算都应该采用补码形式，具体的原因就很多了；
进行补码运算时，应注意所得结果不应超过补码所能表示数的范围；
在以二进制补码表示负数的机器上，~（按位运算符）10的结果为十进制数-11；
等等。</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T11:50:43+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/yi-wei-yun-suan-fu/" itemprop="url">移位运算符</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote>
  <p>移位运算先转化成2进制，再根据运算符指定的位数作以为运算。
左移运算符（«）：逻辑/算数移位。在不考虑溢出的情况下，相当于乘2，移位时移出的位数全部丢弃，右侧补入的数全部是0；左移时要注意有符号数的溢出情况。
右移运算符（»）：算术运算，对于无符号数以及有符号正数相当于除2，移位时溢出的位数全部丢弃，补入的数分为两种情况：如果是无符号数，左侧全部补0；如果是有符号数与符号位和编译器有关，一般情况下补符号位的副本。</p>
</blockquote>

<hr />
<p>移位计数的取值问题：</p>

<ol>
  <li>
    <p>网上查到的结果是如果移动的位数超过类型的长度时，会对移位计数取余，举个小例子：</p>

    <p>int i = 1, j = 0x80000000; //设int为32位
   i = i « 33;     // 33 % 32 = 1 左移1位,i变成2
   j = j « 33;     // 33 % 32 = 1 左移1位,j变成0,最高位被丢弃</p>
  </li>
  <li>
    <p>《C Traps and Pitfalls》这本书上说的是：移位计数必须大于等于0，而严格小于n（如上例的32位），即：i « 32 和 i«-1这种写法都是非法的，我猜是这本书出版的时间比较早，但是我还是更喜欢这样的做法。</p>
  </li>
</ol>

<p>除法运算代替以为运算，将导致程序运行速度大大减慢。换句话说：使用移位预算符将大大提高程序的执行效率。对于这一点我将在自己以后的应用中继续总结。</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T11:49:22+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/uiimageviewhe-uibuttonla-shen-xiao-guo-de-shi-xian/" itemprop="url">UIImageView和UIButton拉伸效果的实现</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>UIImageView中Image拉伸效果的实现：</p>

<pre><code>UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;
</code></pre>

<p>但是虽然UIButton和UIImageView都是继承于UIView，但是二者实现方式不同，UIImageView没有subView，它 的content就是image，UIBotton不同，the way it works is a private implementation detail。</p>

<p>因此UIButton实现背景拉伸，即图片两端不拉伸中间拉伸的办法有如下两种：</p>

<p>第一种方法很简单而且使用性更广。做法就是直接拉伸想要setBackgroundImage的image，代码如下：</p>

<pre><code>UIImage*image =[UIImage imageNamed:@"image.png"];

image = [image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];

image =[image stretchableImageWithLeftCapWidth:floorf(image.size.width/2) topCapHeight:floorf(image.size.height/2)];
</code></pre>

<p>设置了左端帽之后，rightCapWidth = image.size.width - (image.leftCapWidth + 1); 也就是说图片中间的一像素用来拉伸。垂直方向同上。</p>

<p>设置之后无论把image放到什么控件中都可以自动拉伸了。</p>

<p>第二种方法是在UIButton中加入一个UIImageView，拉伸imageView，然后将button的背景设为clearColor等等。把imageView放入button中，并且sendToBack，得到效果。</p>

<p>代码如下：</p>

<pre><code>//刚才imageView拉伸的代码

UIImageView *strechTest = [[UIImageyiView alloc] initWithImage:[UIImage imageNamed:@"test.png"]];
[strechTest setContentStretch:CGRectMake(0.5f, 0.5f, 0.f, 0.f)];
CGRect frame = strechTest.frame;
frame.size.width += 100;
strechTest.frame = frame;

//把imageView放入button中，并设置为back


[temp_button addSubview:backgroundImageView];
[temp_button sendSubviewToBack:backgroundImageView];
[temp_button setBackgroundColor:[UIColor clearColor]];
</code></pre>

<p>button不能设置背景图片，这样就可以实现拉伸的图片作为背景并且背景上可以放置title。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T11:48:12+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/guan-yu-gitfen-zhi-de-shi-yong/" itemprop="url">关于git分支的使用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>学习记录，不正确的地方望指正！</p>

<p>git branch 显示的是本地分支</p>

<p>git pull origin aRemoteBranch</p>

<p>git push origin aRemoteBranch</p>

<p>git commit 是提交到当前的本地分支</p>

<p>git remote显示远程服务器</p>

<p>git remote show aRemote显示指定的远程服务器（origin）上的远程分支</p>

<p>git checkout –track -b aLocalBranch aRemote/aRemoteBranch 创建一个新本地分支追踪远程分支（也可以直接 git checkout aRemoteBranch）</p>

<p>远程分支不可见，只能通过新建本地分支来追踪远程分支，本地分支和远程分支是两个不同的东西，也可以不同名。</p>

<p>checkout的时候会先检查本地分支，如果有则checkout到这个本地分支（不论它track哪个远程分支），如果没有则查看远程分支，如果有同名远程分支则新建一个本地同名分支并追踪（track）远程分支</p>

<p>git branch -d aLocalBranch  删除本地分支</p>

<p>git push ARemote :aRemoteBranch 删除远程分支</p>

<p>-d -&gt; -D 强制删除</p>

<p>vim .git/config</p>

<p>可以查看当前的remote和已经track了remote分支的本地分支</p>

<p>可以建多个本地分支track同一个远程分支，删除本地分支对远程分支没有影响。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T11:07:51+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/apnsshi-xian-xiao-ji/" itemprop="url">APNs实现小记</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote>
  <p>转自己以前写的博客，很早时候的学习笔记了，不过下面几个连接貌似都失效了。。。囧</p>
</blockquote>

<p>推荐如下链接，前两个介绍APNs的设置流程，已经很详尽，虽然很详尽但是个人感觉有些晦涩难懂，把简单的流程搞的复杂。我下面的内容是我设置APNs的过：</p>

<p>[iPhone消息推送服务实现 - vber的专栏 - 博客频道 - CSDN.NET]</p>

<p>[apple push notification service apple与Python结合推送 - iOS开发讨论区 - Tiny4Cocoa]</p>

<table>
  <tbody>
    <tr>
      <td>[编写push notification之获取device token</td>
      <td>Marshal’s Blog]</td>
    </tr>
  </tbody>
</table>

<p><a href="http://slj.me/2010/02/iphone-push-notification/">偷窥iPhone Push Notification的幕后 - SLJ.me - 申力军</a></p>

<table>
  <tbody>
    <tr>
      <td>[iPhone的Push(推送通知)功能原理浅析 - iPhone/iPad 进阶讨论区 - 悦Phone论坛 iPhone</td>
      <td>iPad开发者、苹果开发者]</td>
    </tr>
  </tbody>
</table>

<p> 第一次接触APNs，鼓捣了一下午终于有了点眉目。</p>

<p> 链接1,2的流程介绍都是从最基础的入门级介绍，其实在你开发一款iOS app时，你需要做的是申请开发者帐号，设置Apple ID，生成provisioning file导入到Xcode，而APNs只是在设置Apple ID的时候多选择了一个选项，即Apple ID 的configure页面的 Enable for Apple Push Notification service选项，勾选它，然后根据你的需要生成dev或者release版本的SSL证书（证书生成的过程apple已经给了详尽的提示）。这里要注意的是，勾选了enable for apns之后，其实你的provisioning file已经改变，所以要重新下载新的导入Xcode。</p>

<hr />
<p>此时，你的app已经支持apns了。</p>

<p> 之后需要做的是两个方面：</p>

<ol>
  <li>
    <p>客户端 在appDelegate中编写代码，为了阅读方便就把上面链接中的代码重新贴一次：</p>

    <pre><code> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {  
   [[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |    UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];  
 }  
 - (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err {  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"Error in registration. Error: %@", err] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 }  
 - (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
   NSLog(@"devToken=%@",deviceToken);  
   [self alertNotice:@"" withMSG:[NSString stringWithFormat:@"devToken=%@",deviceToken] cancleButtonTitle:@"Ok" otherButtonTitle:@""];  
 } 
</code></pre>
  </li>
</ol>

<p> 其实就是在appDidFinishLaunch的时候注册（register）apns，然后通过didRegisterForRemoteNotificationsWithDeviceToken得到DeviceToken。</p>

<p>接受服务器消息并改变客户端本地状态（如在app图表显示带数字的小红圈）的代码如下：</p>

<pre><code>	－(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
	
	    for (id key in userInfo) {
	        NSLog(@"key: %@, value: %@", key, [userInfo objectForKey:key]);
	    }    
	}
</code></pre>

<p> 到此为止，当你在真机上运行你的app时就会出现：是否允许app显示push notification的提示框。</p>

<ol>
  <li>服务器端 服务器端可以用PHP，Python等实现，网上也有一些现成的库如开源库APNSWrapper。现在你会发现我理解的思路跟链接1,2的介绍流程稍有不同，同时你会发现我还没有使用Enable for Apple Push Notification service时生成的证书文件，现在回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，关于这个文件要多说几句：</li>
</ol>

<blockquote>
  <p>这个文件的作用是让apple的APNs服务器确认服务器端具有push notification的权限。将这个证书作一定的处理（＊至于是什么处理为了不影响文章的连贯性会在下面介绍），生成一个ck.pem文件（这个名字可以自定义）。</p>
</blockquote>

<p> 然后就要涉及到APNs的工作机制，我的总结如下：当一个device（苹果设备）启用apns功能（就是通知功能）的时候会和apple的APNs服务器建立TLS连接，APNs服务器根据device的UDID和加密密钥新建一个DeviceToken（它的作用是让服务器端指定device，唯一）返回给device，然后device会把device token给你的app客户端，这时会调用刚才写的didRegisterForRemoteNotificationsWithDeviceToken方法，你可以在这个方法中将device token返回给服务器端。此后，如果服务器端push了一个notification给客户端，需要将这个device token和之前处理的ck.pem文件同时发送给APNs服务器，APNs服务器会验证你的ck.pem文件然后根据device token指定的设备推送消息给客户端）。当客户端接受到push的通知时调用didReceiveRemoteNotification方法，你可以在这个方法中放入你需要的操作。</p>

<blockquote>
  <p>现在再回到Apple ID configure页面下载生成的 Development (or Production) Push SSL Certificate 文件，对它的处理链接1,2都有介绍，就是：</p>
</blockquote>

<ol>
  <li>
    <p>选择“我的证书”, 选定推送服务证书(Apple Development Push Services*),导出到桌面,保存为Certificates.p12。</p>
  </li>
  <li>
    <p>在终端中运行如下命令:</p>

 	openssl pkcs12 -clcerts -nokeys -out cert.pem -in Certificates.p12<br />
 	openssl pkcs12 -nocerts -out key.pem -in Certificates.p12<br />
 	openssl rsa -in key.pem -out key.unencrypted.pem<br />
    <pre><code> 	cat cert.pem key.unencrypted.pem &gt; ck.pem  

 ck.pem文件则是PHP推送消息时所使用的证书文件。
</code></pre>
  </li>
</ol>

<p> 你剩下的任务就是编写服务器端的代码，push notification，这部分只要记住发送device token和证书文件就可以了。</p>

<p>（以上就是我理解学习APNs的过程，许多理解都不深入，所以描述也不准确，包涵～）</p>

<h2 id="section">更新：</h2>

<p><strong>开发中遇到的问题汇总</strong>：</p>

<ol>
  <li>
    <p>正常的iPhone刷系统之后，是没有设备证书和密钥的。这就是为什么iPhone会需要连接到 iTunes上进行激活——激活过程中，Apple会分配给每台iPhone独一无二的设备证书(device certificate)和密钥(key)。(如果没有意识到这个会一直收到 “未找到应用程序的”aps-environment” 的权利字符串)</p>
  </li>
  <li>
    <p>如果生成appleID的时候没有enable aps，那么enable之后一定要删掉原来的dev和rc证书重新生成，这样才能保证开启新功能，否则仅仅是刷新这张证书仍然会没有aps，提示（ “未找到应用程序的”aps-environment” 的权利字符串）</p>
  </li>
  <li>
    <p>APNs证书如果是系统证书那么最好拷贝到登陆证书中，这样可以直接导出成p12</p>
  </li>
</ol>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-27T10:50:39+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150627/sigabrtcuo-wu-de-diao-shi-ban-fa/" itemprop="url">SIGABRT错误的调试办法</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>iOS经常会遇到一个头疼的error就是在main函数上显示“ Thread 1: signal SIGABRT ”这个错误，终于在stackoverflow上找到了调试的办法：</p>

<p><a href="http://stackoverflow.com/questions/9782621/i-have-an-error-in-main-m-thread-1-signal-sigabrt-how-can-i-fix-this">原文链接</a></p>

<p>重点就是 <strong>Set an exception breakpoint.</strong></p>

<p>之前我们遇到的在main函数上的那个崩溃信息，如果想要调试就加入一个 an exception breakpoint ，它会在exception 被 cathc 的时候停下来，这样就可以追踪到造成 exception 的代码了。</p>

<p>加入一个exception breakpoint的方法就是：在navigator的断点页面，点击左下角的加号就能看到 exception breakpoint；</p>

<p>加入的时候可以设置，默认是 all，也可以选择针对 oc 还是 c 的断点。</p>

<blockquote>
  <p>原文：</p>

  <p>When you get SIGABRT on that line of main, it means that your program is raising an exception. The stack trace shows where the exception is being caught, &gt;not where it’s being raised. Usually this is not helpful. To debug the problem, you can do two things:</p>

  <ol>
    <li>
      <p>Click the “Continue Program Execution” button in the debugger control bar, or choose Program &gt; Debug &gt; Continue from the menu bar. This will let the program continue the exception-raising process. It will print a message to the debugger console that will help you understand what’s wrong. (You may have &gt;to continue execution a couple of times before it actually prints messages.) Read the messages carefully! They usually continue helpful information.</p>
    </li>
    <li>
      <p>Set an exception breakpoint. This will make Xcode stop your program at the point where the exception is being raised, so you can see the code and the stack trace that is causing the problem.</p>
    </li>
  </ol>
</blockquote>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-06-18T19:19:06+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150618/jspatchdui-bi/" itemprop="url">JSPatch与Wax对比分析</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote>
  <p><a href="https://github.com/bang590/JSPatch">JSPatch</a>与<a href="https://github.com/probablycorey/wax">Wax</a>作为iOS平台上两大热更新框架使用不同的语言、基于相同的原理（ObjC动态绑定）一直备受iOS开发者的青睐，Wax出现较早且已经不再维护，但是也有了各种各样的分支版本；JSPatch作为后起之秀得益于iOS7苹果开放了JavascriptCore.framework的API，相比以前的Wax框架有了很多更新，下面就根据以往的开发经验简单比较一下二者的优势劣势，如果想对两个框架有更多的了解，请移步上文的官方网站和相关文档。</p>
</blockquote>

<ol>
  <li>JSPatch相比于Wax的优势</li>
  <li>JSPatch相比于Wax的劣势</li>
</ol>

<hr />

<h1 id="jspatchwax">JSPatch相比于Wax的优势</h1>

<h2 id="section">内存管理</h2>
<ul>
  <li>JSPatch中JSValue负责维护被引用OC对象的生命周期，如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</li>
  <li>Wax在引用OC对象需要打上waxRetain标记，然后跑一个定时的GC查看这个对象的retainCount，当发现一个不再需要引用的对象retainCount大于1并且waxRetain为YES时（实际上的判断逻辑要复杂一些），就释放这个对象。依赖于retainCount，苹果官方是不推荐的，也不安全。</li>
</ul>

<h2 id="section-1">类型转换</h2>
<ul>
  <li>
    <p>JSPatch使用的是系统提供的类型转换，JSValue类内部可以看到完整的JS类型与OC的映射关系，同时支持NSArray和NSDictionary等类型的嵌套解析;</p>

    <pre><code>  @textblock
     Objective-C type  |   JavaScript type
   --------------------+---------------------
           nil         |     undefined
          NSNull       |        null
         NSString      |       string
         NSNumber      |   number, boolean
       NSDictionary    |   Object object
         NSArray       |    Array object
          NSDate       |     Date object
         NSBlock (1)   |   Function object (1)
            id (2)     |   Wrapper object (2)
          Class (3)    | Constructor object (3)
  @/textblock
</code></pre>
  </li>
  <li>
    <p>Lua中调用OC对象需要使用toobjc方法，否则会Crash，还有一个问题是NSDictionary、NSArray使用时是被copy的，也就是说你无法直接更改OC内存中的那个对象。</p>
  </li>
</ul>

<h2 id="section-2">多线程</h2>
<ul>
  <li>由于JSCore的支持，JS脚本实现的方法在多线程中调用没有任何问题，同时JSPatch也针对GCD提供了封装；</li>
  <li>Lua语言本身是不支持多线程的，多个线程同时调用Lua就等于同时操作同一张Lua元表，可能出问题；同时Wax调用异步的话只能依赖performSelectorInBackground:了。</li>
</ul>

<h2 id="block">Block</h2>
<ul>
  <li>JSPatch：天然支持，JS的Function类型会对应转换成NSBlock执行；</li>
  <li>个人认为Wax最受诟病的一点，无法支持Block使得方法替换和扩展都受到很大限制。</li>
</ul>

<h2 id="section-3">类型扩展</h2>
<ul>
  <li>JSPatch提供了CGRect、CGPoint、NSRange支持</li>
  <li>Lua调用OC对象时需要toobjc，NSDictionary、NSArray只支持copy，不支持retain</li>
</ul>

<h2 id="section-4">参数传递</h2>
<blockquote>
  <p>为了替换方法实现，将方法传递到脚本语言的实现过程中必须知道当前方法的参数类型列表，传统的方法是用va_list得到，但是arm64上va_list的实现更改无法根据内存位置取出参数，对于这个坑也是困了好久才解决。但是个人认为bang牛给了一个更好的解法。</p>
</blockquote>

<ul>
  <li>JSPatch为了解决arm64上va_list拿不到参数的问题，使用forwardInvocation方式，支持各种类型参数枚举；</li>
  <li>Wax框架维护期间还没有出现arm64所以也就一直平静的使用va_list，当然现在升级的话也可以使用JSPatch的这种方式；</li>
</ul>

<h1 id="jspatchwax-1">JSPatch相比于Wax的劣势</h1>

<h2 id="section-5">消息转发</h2>
<ul>
  <li>JS语言不支持消息转发，对于一个对象如果不响应方法就直接崩溃了，所以bang牛用正则替换了方法调用，然后通过桥接方法 __c() 来实现；</li>
  <li>Lua解析后的方法、变量都放到元表中，支持消息转发，算是一个非常好的特性。</li>
</ul>

<h2 id="ios6">iOS6支持</h2>
<ul>
  <li>JSPatch基于JSCore，仅支持iOS7+</li>
  <li>Wax理论上支持所有iOS版本。</li>
</ul>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    Kimimaro


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	<script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'kimimaro';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>




</body>
</html>
